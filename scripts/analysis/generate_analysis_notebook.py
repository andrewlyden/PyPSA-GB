"""
Generate interactive Jupyter notebooks for analyzing PyPSA-GB solved networks.

This script creates a notebook from a template, populated with scenario-specific
analysis code and parameters. The notebook allows interactive exploration of
optimization results including generation mix, storage, line loading, and
renewable curtailment.

Usage:
  This script is called by Snakemake rule 'generate_analysis_notebook'
  
Input:
  - Solved network (PyPSA Network object saved as .nc)
  - Generator summary CSV
  
Output:
  - Interactive Jupyter notebook (.ipynb)
"""

import json
import os
from pathlib import Path
import logging

# Setup logging - handle both Snakemake and standalone execution
try:
    log_file = snakemake.log[0]
except (NameError, AttributeError, IndexError, TypeError):
    log_file = 'generate_notebook.log'

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def create_analysis_notebook(scenario_id, network_path, output_path):
    """
    Create an interactive analysis notebook for a solved PyPSA network.
    
    Args:
        scenario_id: Scenario identifier
        network_path: Path to solved network (.nc file)
        output_path: Path to save notebook (.ipynb file)
    """
    logger.info(f"Generating analysis notebook for scenario: {scenario_id}")
    
    # Create notebook structure
    notebook = {
        "cells": [],
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "name": "python",
                "version": "3.10"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    # Cell 1: Title and description
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            f"# PyPSA-GB Analysis Notebook: {scenario_id}\n",
            "\n",
            "This notebook provides interactive analysis of the solved PyPSA-GB network optimization results.\n",
            "\n",
            "## Contents\n",
            "- Network summary and scenario parameters\n",
            "- Generation mix by technology\n",
            "- Storage dispatch and state of charge\n",
            "- Transmission line loading analysis\n",
            "- Locational marginal prices (LMP)\n",
            "- Renewable curtailment analysis\n",
            "- Demand-side flexibility analysis\n",
            "  - Heat pump flexibility (TANK & COSY modes)\n",
            "  - Electric vehicle flexibility (charging & V2G)\n",
            "  - Demand response events\n",
            "- Key performance indicators (KPIs)\n",
            "\n",
            "**Generated automatically by PyPSA-GB workflow**"
        ]
    })
    
    # Cell 2: Setup and imports
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Import required libraries\n",
            "import os\n",
            "import sys\n",
            "import pypsa\n",
            "import pandas as pd\n",
            "import numpy as np\n",
            "import matplotlib.pyplot as plt\n",
            "import plotly.express as px\n",
            "import plotly.graph_objects as go\n",
            "import plotly.io as pio\n",
            "from plotly.subplots import make_subplots\n",
            "from pyproj import Transformer\n",
            "from pathlib import Path\n",
            "\n",
            "# Configure matplotlib and plotly\n",
            "plt.rcParams.update({'font.size': 12})\n",
            "plt.style.use('ggplot')\n",
            "%matplotlib inline\n",
            "\n",
            "# Configure Plotly to output HTML for Sphinx/nbsphinx compatibility\n",
            "pio.renderers.default = 'notebook_connected'\n",
            "\n",
            "# Suppress warnings\n",
            "import warnings\n",
            "warnings.filterwarnings('ignore')\n",
            "\n",
            "print('✓ Libraries imported successfully')"
        ]
    })
    
    # Cell 3: Load network with robust path resolution
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Load solved network (resolve path robustly from different working directories)\n",
            f"network_rel = Path('{network_path}')\n",
            "network_path = network_rel\n",
            "# If the relative path doesn't exist from the current cwd, search upward for the repository root\n",
            "if not network_path.exists():\n",
            "    for parent in [Path.cwd()] + list(Path.cwd().parents)[:6]:\n",
            "        candidate = parent / network_rel\n",
            "        if candidate.exists():\n",
            "            network_path = candidate\n",
            "            break\n",
            "    else:\n",
            "        # leave as relative; we'll raise a clear error below if not found\n",
            "        network_path = network_rel\n",
            "\n",
            "print(f'Loading network from: {network_path}')\n",
            "\n",
            "if not network_path.exists():\n",
            f"    raise FileNotFoundError(f'Network file not found. Tried: {{network_path}}.\\\\nMake sure \"{network_path}\" exists relative to the repository root.')\n",
            "\n",
            "network = pypsa.Network(str(network_path))\n",
            "\n",
            "# Derive a scenario id from the network filename when not provided\n",
            f"scenario_id = '{scenario_id}'\n",
            "\n",
            "print(f'✓ Network loaded successfully')\n",
            "print(f'  Buses: {len(network.buses)}')\n",
            "print(f'  Generators: {len(network.generators)}')\n",
            "print(f'  Lines: {len(network.lines)}')\n",
            "print(f'  Storage units: {len(network.storage_units)}')\n",
            "print(f'  Timesteps: {len(network.snapshots)}')\n",
            "print(f'  Period: {network.snapshots[0]} to {network.snapshots[-1]}')"
        ]
    })
    
    # Cell 4: Network summary
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Network Summary"
        ]
    })
    
    # Cell 5: Generation mix
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Calculate generation by carrier\n",
            "p_by_carrier = network.generators_t.p.groupby(\n",
            "    network.generators.carrier, axis=1).sum()\n",
            "\n",
            "# Add storage output\n",
            "storage_by_carrier = network.storage_units_t.p.groupby(\n",
            "    network.storage_units.carrier, axis=1).sum()\n",
            "storage_by_carrier[storage_by_carrier < 0] = 0\n",
            "\n",
            "p_by_carrier = pd.concat([p_by_carrier, storage_by_carrier], axis=1)\n",
            "\n",
            "# Add H2_turbine links (hydrogen power plants modeled as links, not generators)\n",
            "if len(network.links) > 0:\n",
            "    h2_turbine_links = network.links[network.links['carrier'] == 'H2_turbine']\n",
            "    if len(h2_turbine_links) > 0 and len(network.links_t.p1) > 0:\n",
            "        # p1 is the power output at bus1 (GB side), which is negative\n",
            "        h2_output = network.links_t.p1[h2_turbine_links.index].abs()\n",
            "        h2_ts = pd.DataFrame({'H2_turbine': h2_output.sum(axis=1)})\n",
            "        p_by_carrier = pd.concat([p_by_carrier, h2_ts], axis=1)\n",
            "        print(f'Added H2_turbine generation: {h2_turbine_links.p_nom.sum():.0f} MW capacity')\n",
            "\n",
            "# Separate interconnectors from internal power lines\n",
            "# Interconnectors connect to external buses (e.g., 'HVDC_External_France')\n",
            "if len(network.links) > 0:\n",
            "    # Identify interconnectors vs internal links by checking for 'external' in bus names\n",
            "    is_interconnector = (\n",
            "        network.links.bus0.str.lower().str.contains('external', na=False) |\n",
            "        network.links.bus1.str.lower().str.contains('external', na=False)\n",
            "    )\n",
            "    interconnector_links = network.links[is_interconnector].index\n",
            "    internal_links = network.links[~is_interconnector].index\n",
            "    \n",
            "    # Get interconnector imports (positive p0 = flow into GB from external)\n",
            "    if len(interconnector_links) > 0:\n",
            "        ic_flows = network.links_t.p0[interconnector_links].copy()\n",
            "        ic_flows[ic_flows < 0] = 0\n",
            "        interconnector_import = pd.DataFrame({'Interconnectors Import': ic_flows.sum(axis=1)})\n",
            "        p_by_carrier = pd.concat([p_by_carrier, interconnector_import], axis=1)\n",
            "    \n",
            "    # Report internal links separately (not included in generation mix)\n",
            "    if len(internal_links) > 0:\n",
            "        print(f'Note: {len(internal_links)} internal power transmission links (not shown in generation mix)')\n",
            "else:\n",
            "    print('No links in network')\n",
            "\n",
            "print('Generation Mix (MWh):')\n",
            "print(p_by_carrier.sum().sort_values(ascending=False))\n",
            "print()\n",
            "print(f'Total demand satisfied: {network.loads_t.p_set.sum().sum():,.0f} MWh')"
        ]
    })
    
    # Cell 6: Interactive generation mix visualization
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Interactive Generation Mix Visualization"
        ]
    })
    
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive stacked area chart with Plotly\n",
            "# Define distinct colors for different technologies (ordered: baseload -> renewables -> peakers)\n",
            "color_map = {\n",
            "    # Baseload (bottom of stack)\n",
            "    'nuclear': '#9467BD',          # Purple - distinctive for nuclear\n",
            "    # Low-carbon dispatchable\n",
            "    'waste_to_energy': '#8C564B',  # Brown\n",
            "    'landfill_gas': '#D2691E',     # Chocolate\n",
            "    'biogas': '#2E8B57',           # Sea green\n",
            "    'sewage_gas': '#556B2F',       # Dark olive\n",
            "    'advanced_biofuel': '#6B8E23', # Olive drab\n",
            "    'biomass': '#228B22',          # Forest green\n",
            "    'Other Bioenergy': '#3CB371',  # Medium sea green (grouped)\n",
            "    # Renewables (variable)\n",
            "    'wind_offshore': '#1E90FF',    # Dodger blue\n",
            "    'wind_onshore': '#00CED1',     # Dark turquoise\n",
            "    'solar_pv': '#FFD700',         # Gold\n",
            "    'large_hydro': '#4169E1',      # Royal blue\n",
            "    'small_hydro': '#87CEEB',      # Sky blue\n",
            "    'tidal_stream': '#20B2AA',     # Light sea green\n",
            "    'shoreline_wave': '#48D1CC',   # Medium turquoise\n",
            "    'Other Renewables': '#5F9EA0', # Cadet blue (grouped)\n",
            "    # Storage (mid-merit)\n",
            "    'battery': '#32CD32',          # Lime green\n",
            "    'Pumped Storage Hydroelectricity': '#00FA9A', # Medium spring green\n",
            "    'pumped_hydro': '#00FA9A',\n",
            "    # Gas (flexible)\n",
            "    'CCGT': '#FF6347',             # Tomato red\n",
            "    'OCGT': '#FF4500',             # Orange red (peaker)\n",
            "    # Coal and other fossil\n",
            "    'coal': '#696969',             # Dim grey\n",
            "    # Imports\n",
            "    'Interconnectors Import': '#DDA0DD', # Plum\n",
            "    'EU_import': '#DA70D6',        # Orchid\n",
            "    # Hydrogen system\n",
            "    'H2': '#00FFFF',               # Cyan (legacy H2 generators)\n",
            "    'H2_turbine': '#00CED1',       # Dark turquoise (H2 to power)\n",
            "    'electrolysis': '#40E0D0',     # Turquoise (power to H2)\n",
            "    'H2_gas': '#7FFFD4',           # Aquamarine (H2 storage)\n",
            "    # Emergency\n",
            "    'load_shedding': '#DC143C'     # Crimson\n",
            "}\n",
            "\n",
            "# Define stacking order: baseload at bottom, peakers at top\n",
            "stacking_order = [\n",
            "    'nuclear',                    # Baseload (bottom)\n",
            "    'waste_to_energy', 'landfill_gas', 'biogas', 'sewage_gas', 'advanced_biofuel', 'biomass', 'Other Bioenergy',\n",
            "    'wind_offshore', 'wind_onshore', 'solar_pv',  # Renewables\n",
            "    'large_hydro', 'small_hydro', 'tidal_stream', 'shoreline_wave', 'Other Renewables',\n",
            "    'battery', 'Pumped Storage Hydroelectricity', 'pumped_hydro',  # Storage\n",
            "    'H2', 'H2_turbine',           # Hydrogen power\n",
            "    'CCGT',                       # Mid-merit gas\n",
            "    'Interconnectors Import', 'EU_import',  # Imports\n",
            "    'coal',                       # Coal\n",
            "    'OCGT',                       # Peaker\n",
            "    'load_shedding'               # Emergency (top)\n",
            "]\n",
            "\n",
            "# Group small contributors (<1% of total) into 'Other' categories\n",
            "total_gen = p_by_carrier.sum().sum()\n",
            "threshold = total_gen * 0.01  # 1% threshold\n",
            "\n",
            "# Identify small bioenergy and renewable types to group\n",
            "bioenergy_types = ['biogas', 'sewage_gas', 'advanced_biofuel', 'landfill_gas']\n",
            "renewable_types = ['tidal_stream', 'shoreline_wave', 'small_hydro']\n",
            "\n",
            "p_by_carrier_grouped = p_by_carrier.copy()\n",
            "\n",
            "# Group small bioenergy\n",
            "small_bio = [c for c in bioenergy_types if c in p_by_carrier.columns and p_by_carrier[c].sum() < threshold]\n",
            "if len(small_bio) > 0:\n",
            "    p_by_carrier_grouped['Other Bioenergy'] = p_by_carrier_grouped[small_bio].sum(axis=1)\n",
            "    p_by_carrier_grouped = p_by_carrier_grouped.drop(columns=small_bio)\n",
            "\n",
            "# Group small renewables\n",
            "small_ren = [c for c in renewable_types if c in p_by_carrier.columns and p_by_carrier[c].sum() < threshold]\n",
            "if len(small_ren) > 0:\n",
            "    p_by_carrier_grouped['Other Renewables'] = p_by_carrier_grouped[small_ren].sum(axis=1)\n",
            "    p_by_carrier_grouped = p_by_carrier_grouped.drop(columns=small_ren)\n",
            "\n",
            "# Select columns with generation > 0\n",
            "cols_with_gen = p_by_carrier_grouped.sum()[p_by_carrier_grouped.sum() > 0].index.tolist()\n",
            "\n",
            "# Sort by stacking order\n",
            "cols_to_plot = [c for c in stacking_order if c in cols_with_gen]\n",
            "# Add any remaining columns not in stacking_order\n",
            "cols_to_plot += [c for c in cols_with_gen if c not in cols_to_plot]\n",
            "\n",
            "# Create interactive stacked area chart\n",
            "fig = go.Figure()\n",
            "\n",
            "for col in cols_to_plot:  # Stack in order\n",
            "    fig.add_trace(go.Scatter(\n",
            "        x=p_by_carrier_grouped.index,\n",
            "        y=p_by_carrier_grouped[col] / 1e3,  # Convert to GW\n",
            "        name=col.replace('_', ' ').title(),\n",
            "        mode='lines',\n",
            "        stackgroup='one',\n",
            "        fillcolor=color_map.get(col, '#CCCCCC'),\n",
            "        line=dict(width=0.5, color=color_map.get(col, '#CCCCCC')),\n",
            "        hovertemplate='<b>%{fullData.name}</b><br>' +\n",
            "                      'Time: %{x}<br>' +\n",
            "                      'Power: %{y:.2f} GW<br>' +\n",
            "                      '<extra></extra>'\n",
            "    ))\n",
            "\n",
            "fig.update_layout(\n",
            f"    title=dict(text='Generation Mix - {scenario_id}', x=0.5, xanchor='center'),\n",
            "    xaxis_title='Time',\n",
            "    yaxis_title='Generation (GW)',\n",
            "    hovermode='x unified',\n",
            "    height=600,\n",
            "    legend=dict(\n",
            "        orientation='v',\n",
            "        yanchor='top',\n",
            "        y=1,\n",
            "        xanchor='left',\n",
            "        x=1.02\n",
            "    ),\n",
            "    template='plotly_white'\n",
            ")\n",
            "\n",
            "fig.show()\n",
            "print('Stacking order: Baseload (bottom) -> Renewables -> Storage -> Gas -> Peakers (top)')\n",
            "print('Tip: Click legend items to show/hide technologies. Double-click to isolate one.')"
        ]
    })
    
    # Cell 7a: Interactive Network Topology Map
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Interactive Network Topology\n",
            "\n",
            "Explore the network topology with interactive maps showing bus locations, transmission lines/links, and generators overlaid on a GB map."
        ]
    })
    
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive network map using PyPSA's explore() function\n",
            "# Select a representative snapshot for visualization\n",
            "snapshot_idx = len(network.snapshots) // 2\n",
            "snapshot = network.snapshots[snapshot_idx]\n",
            "\n",
            "print(f'Visualizing network at snapshot: {snapshot}')\n",
            "\n",
            "# Detect network type based on bus count\n",
            "is_zonal = len(network.buses) < 50 and len(network.lines) == 0 and len(network.links) > 0\n",
            "is_reduced = len(network.buses) < 100 and len(network.buses) >= 30\n",
            "network_type = 'Zonal' if is_zonal else ('Reduced' if is_reduced else 'ETYS')\n",
            "print(f'Network type detected: {network_type} ({len(network.buses)} buses)')\n",
            "\n",
            "# Network topology visualization (electricity only, no hydrogen)\n",
            "try:\n",
            "    import copy\n",
            "    import folium\n",
            "    if 'x' in getattr(network.buses, 'columns', []) and 'y' in getattr(network.buses, 'columns', []):\n",
            "        # Filter out hydrogen buses and links\n",
            "        h2_carriers = ['electrolysis', 'H2_turbine', 'H2_power', 'H2', 'H2_gas', 'H2 pipeline']\n",
            "        h2_buses = set()\n",
            "        if 'carrier' in network.buses.columns:\n",
            "            h2_buses = set(network.buses[network.buses.carrier.isin(h2_carriers)].index)\n",
            "        \n",
            "        # Create filtered network copy\n",
            "        network_plot = copy.deepcopy(network)\n",
            "        \n",
            "        # Remove hydrogen buses if any found\n",
            "        if len(h2_buses) > 0:\n",
            "            for bus_id in h2_buses:\n",
            "                if bus_id in network_plot.buses.index:\n",
            "                    network_plot.remove('Bus', bus_id)\n",
            "        \n",
            "        # Also filter hydrogen links\n",
            "        if len(network_plot.links) > 0 and 'carrier' in network_plot.links.columns:\n",
            "            h2_links = network_plot.links[network_plot.links.carrier.isin(h2_carriers)].index\n",
            "            for link_id in h2_links:\n",
            "                if link_id in network_plot.links.index:\n",
            "                    network_plot.remove('Link', link_id)\n",
            "        \n",
            "        # Convert OSGB -> WGS84 lon/lat for mapping\n",
            "        t = Transformer.from_crs('EPSG:27700', 'EPSG:4326', always_xy=True)\n",
            "        lon, lat = t.transform(network_plot.buses['x'].to_numpy(), network_plot.buses['y'].to_numpy())\n",
            "        network_plot.buses['x'] = lon\n",
            "        network_plot.buses['y'] = lat\n",
            "        \n",
            "        print(f'Electricity network: {len(network_plot.buses)} buses, {len(network_plot.lines)} lines, {len(network_plot.links)} links')\n",
            "        \n",
            "        # Create interactive map\n",
            "        m = network_plot.plot.explore(map_style='light', tooltip=True)\n",
            "        display(m)\n",
            "        print('✓ Network topology displayed (electricity only)')\n",
            "    else:\n",
            "        print('⚠️  No bus coordinates (x, y) found. Network visualization requires coordinate data.')\n",
            "except Exception as e:\n",
            "    print(f'⚠️  Network topology map unavailable: {e}')\n",
            "    import traceback\n",
            "    traceback.print_exc()"
        ]
    })
    
    # Cell 7b: Network map with line/link loading (handles both ETYS lines and Zonal links)
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive network map showing transmission loading using PyPSA explore\n",
            "try:\n",
            "    import copy\n",
            "    \n",
            "    import folium\n",
            "    from folium import plugins\n",
            "    \n",
            "    # Detect transmission element type (electricity only)\n",
            "    has_lines = len(network.lines) > 0 and 's_nom' in network.lines.columns\n",
            "    has_internal_links = False\n",
            "    \n",
            "    if has_lines:\n",
            "        # ETYS/Reduced network - use lines\n",
            "        loading = (network.lines_t.p0.loc[snapshot].abs() / network.lines.s_nom).fillna(0)\n",
            "        component_type = 'lines'\n",
            "    elif len(network.links) > 0:\n",
            "        # Zonal network - use internal electricity links only\n",
            "        h2_carriers = ['electrolysis', 'H2_turbine', 'H2_power', 'H2', 'H2_gas', 'H2 pipeline']\n",
            "        is_external = (\n",
            "            network.links.bus0.str.lower().str.contains('external', na=False) |\n",
            "            network.links.bus1.str.lower().str.contains('external', na=False)\n",
            "        )\n",
            "        is_h2_link = network.links.carrier.isin(h2_carriers)\n",
            "        internal_links = network.links[~is_external & ~is_h2_link]\n",
            "        if len(internal_links) > 0 and snapshot in network.links_t.p0.index:\n",
            "            link_flows = network.links_t.p0.loc[snapshot, internal_links.index].abs()\n",
            "            loading = (link_flows / internal_links.p_nom).fillna(0)\n",
            "            component_type = 'links'\n",
            "            has_internal_links = True\n",
            "        else:\n",
            "            loading = pd.Series(dtype=float)\n",
            "    \n",
            "    if len(loading) > 0:\n",
            "        # Convert bus coordinates\n",
            "        t = Transformer.from_crs('EPSG:27700', 'EPSG:4326', always_xy=True)\n",
            "        bus_lon, bus_lat = t.transform(network.buses['x'].to_numpy(), network.buses['y'].to_numpy())\n",
            "        bus_coords = pd.DataFrame({'lon': bus_lon, 'lat': bus_lat}, index=network.buses.index)\n",
            "        \n",
            "        # Create folium map\n",
            "        center_lat = bus_coords['lat'].mean()\n",
            "        center_lon = bus_coords['lon'].mean()\n",
            "        m = folium.Map(location=[center_lat, center_lon], zoom_start=5, tiles='CartoDB positron')\n",
            "        \n",
            "        # Color function\n",
            "        def get_color_by_loading(load_val):\n",
            "            if load_val >= 0.95: return '#DC143C'  # Crimson (>95%)\n",
            "            elif load_val >= 0.80: return '#FF8C00'  # Orange (80-95%)\n",
            "            elif load_val >= 0.60: return '#FFD700'  # Gold (60-80%)\n",
            "            else: return '#228B22'  # Green (<60%)\n",
            "        \n",
            "        # Draw transmission elements with loading colors\n",
            "        if has_lines:\n",
            "            for line_id, load_val in loading.items():\n",
            "                line = network.lines.loc[line_id]\n",
            "                bus0_coords = [bus_coords.loc[line.bus0, 'lat'], bus_coords.loc[line.bus0, 'lon']]\n",
            "                bus1_coords = [bus_coords.loc[line.bus1, 'lat'], bus_coords.loc[line.bus1, 'lon']]\n",
            "                color = get_color_by_loading(load_val)\n",
            "                weight = 0.5 + (load_val * 4)  # Width scales with loading\n",
            "                folium.PolyLine(\n",
            "                    [bus0_coords, bus1_coords],\n",
            "                    color=color,\n",
            "                    weight=weight,\n",
            "                    opacity=0.7,\n",
            "                    tooltip=f'{line_id}: {load_val*100:.1f}% loaded'\n",
            "                ).add_to(m)\n",
            "        elif has_internal_links:\n",
            "            for link_id, load_val in loading.items():\n",
            "                link = network.links.loc[link_id]\n",
            "                bus0_coords = [bus_coords.loc[link.bus0, 'lat'], bus_coords.loc[link.bus0, 'lon']]\n",
            "                bus1_coords = [bus_coords.loc[link.bus1, 'lat'], bus_coords.loc[link.bus1, 'lon']]\n",
            "                color = get_color_by_loading(load_val)\n",
            "                weight = 0.5 + (load_val * 4)\n",
            "                folium.PolyLine(\n",
            "                    [bus0_coords, bus1_coords],\n",
            "                    color=color,\n",
            "                    weight=weight,\n",
            "                    opacity=0.7,\n",
            "                    tooltip=f'{link_id}: {load_val*100:.1f}% loaded'\n",
            "                ).add_to(m)\n",
            "        \n",
            "        # Add small bus markers\n",
            "        for bus_id, row in bus_coords.iterrows():\n",
            "            folium.CircleMarker(\n",
            "                location=[row['lat'], row['lon']],\n",
            "                radius=2,\n",
            "                color='orange',\n",
            "                fill=True,\n",
            "                fillOpacity=0.6,\n",
            "                tooltip=bus_id\n",
            "            ).add_to(m)\n",
            "        \n",
            "        display(m)\n",
            "        \n",
            "        # Print statistics\n",
            "        print(f'\\nTransmission Loading ({component_type}) at {snapshot}:')\n",
            "        print(f'  Max: {loading.max()*100:.1f}% | Mean: {loading.mean()*100:.1f}%')\n",
            "        print(f'  >95% loaded: {(loading >= 0.95).sum()} | >80% loaded: {(loading >= 0.80).sum()}')\n",
            "        print('Color legend: Green (<60%) → Gold (60-80%) → Orange (80-95%) → Red (>95%)')\n",
            "    else:\n",
            "        print(f'⚠️  No transmission loading data available at {snapshot}')\n",
            "except Exception as e:\n",
            "    print(f'⚠️  Transmission loading map unavailable: {e}')\n",
            "    import traceback\n",
            "    traceback.print_exc()"
        ]
    })
    #cell
    # Cell 7c: Generator dispatch map (using PyPSA explore with bus size encoding)
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive network map showing generator dispatch (electricity only)\n",
            "try:\n",
            "    import folium\n",
            "    \n",
            "    # Get total generation per bus at snapshot (exclude hydrogen generators)\n",
            "    h2_carriers = ['electrolysis', 'H2_turbine', 'H2_power', 'H2']\n",
            "    elec_gens = network.generators[~network.generators.carrier.isin(h2_carriers)]\n",
            "    gen_per_bus = network.generators_t.p.loc[snapshot, elec_gens.index].groupby(elec_gens.bus).sum()\n",
            "    gen_per_bus = gen_per_bus[gen_per_bus > 0]  # Only buses with generation\n",
            "    \n",
            "    if len(gen_per_bus) > 0 and 'x' in getattr(network.buses, 'columns', []):\n",
            "        # Convert bus coordinates\n",
            "        t = Transformer.from_crs('EPSG:27700', 'EPSG:4326', always_xy=True)\n",
            "        bus_lon, bus_lat = t.transform(network.buses['x'].to_numpy(), network.buses['y'].to_numpy())\n",
            "        bus_coords = pd.DataFrame({'lon': bus_lon, 'lat': bus_lat}, index=network.buses.index)\n",
            "        \n",
            "        # Create folium map\n",
            "        center_lat = bus_coords['lat'].mean()\n",
            "        center_lon = bus_coords['lon'].mean()\n",
            "        m = folium.Map(location=[center_lat, center_lon], zoom_start=5, tiles='CartoDB positron')\n",
            "        \n",
            "        # Draw light gray transmission lines in background\n",
            "        if len(network.lines) > 0:\n",
            "            for line_id, line in network.lines.iterrows():\n",
            "                bus0_coords = [bus_coords.loc[line.bus0, 'lat'], bus_coords.loc[line.bus0, 'lon']]\n",
            "                bus1_coords = [bus_coords.loc[line.bus1, 'lat'], bus_coords.loc[line.bus1, 'lon']]\n",
            "                folium.PolyLine([bus0_coords, bus1_coords], color='lightgray', weight=0.5, opacity=0.3).add_to(m)\n",
            "        \n",
            "        # Color and size encoding for generation\n",
            "        max_gen = gen_per_bus.max()\n",
            "        def color_by_generation(gen_val):\n",
            "            norm = gen_val / max_gen\n",
            "            if norm < 0.25: return '#FFE4E1'  # Misty rose\n",
            "            elif norm < 0.50: return '#FF9999'  # Light red\n",
            "            elif norm < 0.75: return '#FF6666'  # Red\n",
            "            else: return '#CC0000'  # Dark red\n",
            "        \n",
            "        # Draw bus markers sized and colored by generation\n",
            "        for bus_id, gen_mw in gen_per_bus.items():\n",
            "            coords = bus_coords.loc[bus_id]\n",
            "            norm_gen = gen_mw / max_gen\n",
            "            radius = 3 + (norm_gen * 12)  # Size 3-15 pixels\n",
            "            color = color_by_generation(gen_mw)\n",
            "            folium.CircleMarker(\n",
            "                location=[coords['lat'], coords['lon']],\n",
            "                radius=radius,\n",
            "                color=color,\n",
            "                fill=True,\n",
            "                fillColor=color,\n",
            "                fillOpacity=0.7,\n",
            "                tooltip=f'{bus_id}: {gen_mw:.1f} MW'\n",
            "            ).add_to(m)\n",
            "        \n",
            "        display(m)\n",
            "        \n",
            "        # Statistics\n",
            "        print(f'\\nGenerator Dispatch at {snapshot}:')\n",
            "        print(f'  Total generation: {gen_per_bus.sum():,.0f} MW')\n",
            "        print(f'  Active buses: {len(gen_per_bus[gen_per_bus > 0])}')\n",
            "        print(f'  Max at single bus: {gen_per_bus.max():,.0f} MW')\n",
            "        print('Color legend: Light gray (no gen) → Light red → Dark red (peak generation)')\n",
            "    else:\n",
            "        print('⚠️  No generator dispatch data available at this snapshot')\n",
            "except Exception as e:\n",
            "    print(f'⚠️  Generator dispatch map unavailable: {e}')\n",
            "    import traceback\n",
            "    traceback.print_exc()"
        ]
    })
    
    # Cell 7: Interactive installed capacity bar chart (already updated above)
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive installed capacity by carrier\n",
            "generators_p_nom = network.generators.p_nom.groupby(\n",
            "    network.generators.carrier).sum().sort_values(ascending=True)\n",
            "\n",
            "# Remove small contributors\n",
            "generators_p_nom = generators_p_nom[generators_p_nom > 50]\n",
            "\n",
            "# Create interactive bar chart\n",
            "fig = go.Figure()\n",
            "\n",
            "fig.add_trace(go.Bar(\n",
            "    y=generators_p_nom.index,\n",
            "    x=generators_p_nom.values,\n",
            "    orientation='h',\n",
            "    marker=dict(\n",
            "        color=[color_map.get(c, '#CCCCCC') for c in generators_p_nom.index],\n",
            "    ),\n",
            "    text=[f'{val:,.0f} MW' for val in generators_p_nom.values],\n",
            "    textposition='auto',\n",
            "    hovertemplate='<b>%{y}</b><br>Capacity: %{x:,.0f} MW<extra></extra>'\n",
            "))\n",
            "\n",
            "fig.update_layout(\n",
            f"    title=dict(text='Generator Capacity by Technology - {scenario_id}', x=0.5, xanchor='center'),\n",
            "    xaxis_title='Installed Capacity (MW)',\n",
            "    yaxis_title='',\n",
            "    height=500,\n",
            "    template='plotly_white',\n",
            "    showlegend=False\n",
            ")\n",
            "\n",
            "fig.show()"
        ]
    })
    
    # Cell 8: Storage analysis
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Storage Analysis"
        ]
    })
    
    # Cell 9: Interactive storage analysis
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive storage dispatch and state of charge visualization\n",
            "if len(network.storage_units) > 0:\n",
            "    p_storage = network.storage_units_t.p.sum(axis=1)\n",
            "    state_of_charge = network.storage_units_t.state_of_charge.sum(axis=1)\n",
            "    \n",
            "    # Create subplot with two y-axes\n",
            "    fig = make_subplots(\n",
            "        rows=2, cols=1,\n",
            "        subplot_titles=('Storage Dispatch', 'State of Charge'),\n",
            "        vertical_spacing=0.12\n",
            "    )\n",
            "    \n",
            "    # Storage dispatch\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=p_storage.index,\n",
            "            y=p_storage.values,\n",
            "            name='Storage Dispatch',\n",
            "            line=dict(color='#32CD32', width=1.5),\n",
            "            fill='tozeroy',\n",
            "            fillcolor='rgba(50, 205, 50, 0.3)',\n",
            "            hovertemplate='Time: %{x}<br>Power: %{y:.0f} MW<extra></extra>'\n",
            "        ),\n",
            "        row=1, col=1\n",
            "    )\n",
            "    \n",
            "    # State of charge\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=state_of_charge.index,\n",
            "            y=state_of_charge.values,\n",
            "            name='State of Charge',\n",
            "            line=dict(color='#00CED1', width=1.5),\n",
            "            fill='tozeroy',\n",
            "            fillcolor='rgba(0, 206, 209, 0.3)',\n",
            "            hovertemplate='Time: %{x}<br>Energy: %{y:.0f} MWh<extra></extra>'\n",
            "        ),\n",
            "        row=2, col=1\n",
            "    )\n",
            "    \n",
            "    fig.update_xaxes(title_text='Time', row=2, col=1)\n",
            "    fig.update_yaxes(title_text='Power (MW)', row=1, col=1)\n",
            "    fig.update_yaxes(title_text='Energy (MWh)', row=2, col=1)\n",
            "    \n",
            "    fig.update_layout(\n",
            f"        title=dict(text='Storage Analysis - {scenario_id}', x=0.5, xanchor='center'),\n",
            "        height=700,\n",
            "        hovermode='x unified',\n",
            "        template='plotly_white',\n",
            "        showlegend=True\n",
            "    )\n",
            "    \n",
            "    fig.show()\n",
            "    \n",
            "    # Storage statistics\n",
            "    print(f'\\nStorage Statistics:')\n",
            "    print(f'  Total storage capacity: {network.storage_units.p_nom.sum():,.0f} MW')\n",
            "    print(f'  Total energy capacity: {network.storage_units.max_hours.sum() * network.storage_units.p_nom.sum():,.0f} MWh')\n",
            "    print(f'  Peak discharge: {p_storage.max():,.0f} MW')\n",
            "    print(f'  Peak charge: {p_storage.min():,.0f} MW')\n",
            "    print(f'  Max state of charge: {state_of_charge.max():,.0f} MWh')\n",
            "else:\n",
            "    print('No storage units in network')"
        ]
    })
    
    # Cell: Hydrogen System Analysis
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Hydrogen System Analysis\n",
            "\n",
            "The hydrogen system models the Power-to-Gas-to-Power pathway:\n",
            "- **Electrolysis**: Converts electricity to hydrogen (stored in central H2 bus)\n",
            "- **H2 Storage**: Central hydrogen storage (copper-plate model)\n",
            "- **H2 Turbines**: Converts hydrogen back to electricity when needed"
        ]
    })
    
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Hydrogen System Analysis\n",
            "# Check if hydrogen system exists\n",
            "has_electrolysis = len(network.links) > 0 and 'electrolysis' in network.links.carrier.values\n",
            "has_h2_turbines = len(network.links) > 0 and 'H2_turbine' in network.links.carrier.values\n",
            "has_h2_stores = len(network.stores) > 0 and 'H2_gas' in network.stores.carrier.values\n",
            "\n",
            "if has_electrolysis or has_h2_turbines:\n",
            "    print('=' * 80)\n",
            "    print('HYDROGEN SYSTEM SUMMARY')\n",
            "    print('=' * 80)\n",
            "    \n",
            "    # Electrolysis\n",
            "    if has_electrolysis:\n",
            "        electrolysis = network.links[network.links.carrier == 'electrolysis']\n",
            "        elec_capacity = electrolysis.p_nom.sum()\n",
            "        elec_consumed = network.links_t.p0[electrolysis.index].sum().sum() / 1000  # GWh\n",
            "        elec_efficiency = electrolysis.efficiency.mean()\n",
            "        h2_produced = elec_consumed * elec_efficiency  # GWh H2\n",
            "        print(f'\\nELECTROLYSIS:')\n",
            "        print(f'  Capacity: {elec_capacity:,.0f} MW ({len(electrolysis)} units)')\n",
            "        print(f'  Efficiency: {elec_efficiency*100:.0f}%')\n",
            "        print(f'  Electricity consumed: {elec_consumed:,.1f} GWh')\n",
            "        print(f'  Hydrogen produced: {h2_produced:,.1f} GWh_H2')\n",
            "    \n",
            "    # H2 Turbines\n",
            "    if has_h2_turbines:\n",
            "        h2_turbines = network.links[network.links.carrier == 'H2_turbine']\n",
            "        turbine_capacity = h2_turbines.p_nom.sum()\n",
            "        h2_consumed = network.links_t.p0[h2_turbines.index].sum().sum() / 1000  # GWh H2\n",
            "        turbine_efficiency = h2_turbines.efficiency.mean()\n",
            "        elec_generated = h2_consumed * turbine_efficiency  # GWh electricity\n",
            "        print(f'\\nH2 TURBINES:')\n",
            "        print(f'  Capacity: {turbine_capacity:,.0f} MW ({len(h2_turbines)} units)')\n",
            "        print(f'  Efficiency: {turbine_efficiency*100:.0f}%')\n",
            "        print(f'  Hydrogen consumed: {h2_consumed:,.1f} GWh_H2')\n",
            "        print(f'  Electricity generated: {elec_generated:,.1f} GWh')\n",
            "    \n",
            "    # H2 Storage\n",
            "    if has_h2_stores:\n",
            "        h2_stores = network.stores[network.stores.carrier == 'H2_gas']\n",
            "        h2_storage_capacity = h2_stores.e_nom.sum()\n",
            "        print(f'\\nH2 STORAGE:')\n",
            "        print(f'  Energy capacity: {h2_storage_capacity:,.0f} MWh ({h2_storage_capacity/1000:.0f} GWh)')\n",
            "        if h2_stores.index[0] in network.stores_t.e.columns:\n",
            "            soc = network.stores_t.e[h2_stores.index[0]]\n",
            "            print(f'  State of charge range: {soc.min():,.0f} - {soc.max():,.0f} MWh')\n",
            "            print(f'  Final state of charge: {soc.iloc[-1]:,.0f} MWh')\n",
            "    \n",
            "    # Round-trip efficiency\n",
            "    if has_electrolysis and has_h2_turbines:\n",
            "        roundtrip_eff = elec_efficiency * turbine_efficiency\n",
            "        print(f'\\nSYSTEM METRICS:')\n",
            "        print(f'  Round-trip efficiency: {roundtrip_eff*100:.1f}%')\n",
            "        if elec_consumed > 0:\n",
            "            actual_roundtrip = elec_generated / elec_consumed\n",
            "            print(f'  Actual energy ratio (elec out / elec in): {actual_roundtrip*100:.1f}%')\n",
            "else:\n",
            "    print('No hydrogen system components found in this network.')\n",
            "    print('(Hydrogen components are added for future scenarios with H2 power generation)')"
        ]
    })
    
    # Hydrogen dispatch visualization
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Hydrogen System Dispatch Visualization\n",
            "has_electrolysis = len(network.links) > 0 and 'electrolysis' in network.links.carrier.values\n",
            "has_h2_turbines = len(network.links) > 0 and 'H2_turbine' in network.links.carrier.values\n",
            "has_h2_stores = len(network.stores) > 0 and 'H2_gas' in network.stores.carrier.values\n",
            "\n",
            "if has_electrolysis and has_h2_turbines:\n",
            "    electrolysis = network.links[network.links.carrier == 'electrolysis']\n",
            "    h2_turbines = network.links[network.links.carrier == 'H2_turbine']\n",
            "    \n",
            "    # Electrolysis power consumption (positive = consuming electricity)\n",
            "    elec_power = network.links_t.p0[electrolysis.index].sum(axis=1) / 1000  # GW\n",
            "    \n",
            "    # H2 turbine power generation (p1 is output, negative means generation)\n",
            "    turbine_power = -network.links_t.p1[h2_turbines.index].sum(axis=1) / 1000  # GW\n",
            "    \n",
            "    # Net hydrogen flow (positive = production, negative = consumption)\n",
            "    h2_production = elec_power * electrolysis.efficiency.mean()  # GW H2 produced\n",
            "    h2_consumption = network.links_t.p0[h2_turbines.index].sum(axis=1) / 1000  # GW H2 consumed\n",
            "    \n",
            "    # Create visualization\n",
            "    fig = make_subplots(\n",
            "        rows=3, cols=1,\n",
            "        subplot_titles=(\n",
            "            'Electrolysis (Electricity Consumed)',\n",
            "            'H2 Turbines (Electricity Generated)',\n",
            "            'H2 Storage State of Charge'\n",
            "        ),\n",
            "        vertical_spacing=0.1\n",
            "    )\n",
            "    \n",
            "    # Electrolysis power\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=elec_power.index,\n",
            "            y=elec_power.values,\n",
            "            name='Electrolysis',\n",
            "            line=dict(color='#00CED1', width=1.5),\n",
            "            fill='tozeroy',\n",
            "            fillcolor='rgba(0, 206, 209, 0.3)',\n",
            "            hovertemplate='Time: %{x}<br>Power: %{y:.2f} GW<extra></extra>'\n",
            "        ),\n",
            "        row=1, col=1\n",
            "    )\n",
            "    \n",
            "    # H2 turbine power\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=turbine_power.index,\n",
            "            y=turbine_power.values,\n",
            "            name='H2 Turbines',\n",
            "            line=dict(color='#FF6347', width=1.5),\n",
            "            fill='tozeroy',\n",
            "            fillcolor='rgba(255, 99, 71, 0.3)',\n",
            "            hovertemplate='Time: %{x}<br>Power: %{y:.2f} GW<extra></extra>'\n",
            "        ),\n",
            "        row=2, col=1\n",
            "    )\n",
            "    \n",
            "    # H2 storage state of charge\n",
            "    if has_h2_stores:\n",
            "        h2_stores = network.stores[network.stores.carrier == 'H2_gas']\n",
            "        if h2_stores.index[0] in network.stores_t.e.columns:\n",
            "            h2_soc = network.stores_t.e[h2_stores.index[0]] / 1000  # GWh\n",
            "            fig.add_trace(\n",
            "                go.Scatter(\n",
            "                    x=h2_soc.index,\n",
            "                    y=h2_soc.values,\n",
            "                    name='H2 Storage',\n",
            "                    line=dict(color='#9467BD', width=1.5),\n",
            "                    fill='tozeroy',\n",
            "                    fillcolor='rgba(148, 103, 189, 0.3)',\n",
            "                    hovertemplate='Time: %{x}<br>Energy: %{y:.1f} GWh<extra></extra>'\n",
            "                ),\n",
            "                row=3, col=1\n",
            "            )\n",
            "    \n",
            "    fig.update_yaxes(title_text='Power (GW)', row=1, col=1)\n",
            "    fig.update_yaxes(title_text='Power (GW)', row=2, col=1)\n",
            "    fig.update_yaxes(title_text='Energy (GWh)', row=3, col=1)\n",
            "    fig.update_xaxes(title_text='Time', row=3, col=1)\n",
            "    \n",
            "    fig.update_layout(\n",
            f"        title=dict(text='Hydrogen System Dispatch - {scenario_id}', x=0.5, xanchor='center'),\n",
            "        height=900,\n",
            "        hovermode='x unified',\n",
            "        template='plotly_white',\n",
            "        showlegend=True\n",
            "    )\n",
            "    \n",
            "    fig.show()\n",
            "    \n",
            "    # Correlation analysis\n",
            "    print('\\nDispatch Patterns:')\n",
            "    print(f'  Peak electrolysis: {elec_power.max():.2f} GW at {elec_power.idxmax()}')\n",
            "    print(f'  Peak H2 turbine: {turbine_power.max():.2f} GW at {turbine_power.idxmax()}')\n",
            "    print(f'  Capacity factor (electrolysis): {elec_power.mean() / (electrolysis.p_nom.sum()/1000) * 100:.1f}%')\n",
            "    print(f'  Capacity factor (H2 turbines): {turbine_power.mean() / (h2_turbines.p_nom.sum()/1000) * 100:.1f}%')\n",
            "else:\n",
            "    print('Hydrogen dispatch visualization not available (no hydrogen system components)')"
        ]
    })
    
    # Cell: Hydrogen Network Spatial Map
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive spatial map of hydrogen infrastructure\n",
            "try:\n",
            "    import folium\n",
            "    \n",
            "    has_h2_system = (\n",
            "        (len(network.links) > 0 and any(network.links.carrier.isin(['electrolysis', 'H2_turbine', 'H2 pipeline']))) or\n",
            "        (len(network.stores) > 0 and 'H2_gas' in network.stores.carrier.values)\n",
            "    )\n",
            "    \n",
            "    if has_h2_system and 'x' in network.buses.columns:\n",
            "        # Convert all bus coordinates\n",
            "        t = Transformer.from_crs('EPSG:27700', 'EPSG:4326', always_xy=True)\n",
            "        bus_lon, bus_lat = t.transform(network.buses['x'].to_numpy(), network.buses['y'].to_numpy())\n",
            "        bus_coords = pd.DataFrame({'lon': bus_lon, 'lat': bus_lat}, index=network.buses.index)\n",
            "        \n",
            "        # Create map centered on GB\n",
            "        center_lat = bus_coords['lat'].mean()\n",
            "        center_lon = bus_coords['lon'].mean()\n",
            "        m = folium.Map(location=[center_lat, center_lon], zoom_start=5, tiles='CartoDB positron')\n",
            "        \n",
            "        # 1. Draw H2 pipelines (H2 pipeline links)\n",
            "        if len(network.links) > 0:\n",
            "            h2_pipelines = network.links[network.links.carrier == 'H2 pipeline']\n",
            "            if len(h2_pipelines) > 0:\n",
            "                for link_id, link in h2_pipelines.iterrows():\n",
            "                    if link.bus0 in bus_coords.index and link.bus1 in bus_coords.index:\n",
            "                        bus0_coords = [bus_coords.loc[link.bus0, 'lat'], bus_coords.loc[link.bus0, 'lon']]\n",
            "                        bus1_coords = [bus_coords.loc[link.bus1, 'lat'], bus_coords.loc[link.bus1, 'lon']]\n",
            "                        capacity_mw = link.p_nom\n",
            "                        folium.PolyLine(\n",
            "                            [bus0_coords, bus1_coords],\n",
            "                            color='#00CED1',  # Cyan for H2 pipelines\n",
            "                            weight=3,\n",
            "                            opacity=0.7,\n",
            "                            tooltip=f'H2 Pipeline: {link_id}<br>Capacity: {capacity_mw:.0f} MW'\n",
            "                        ).add_to(m)\n",
            "                print(f'Added {len(h2_pipelines)} H2 pipelines to map')\n",
            "        \n",
            "        # 2. Draw electrolysis links (electricity -> H2) and facilities\n",
            "        if len(network.links) > 0:\n",
            "            electrolysis = network.links[network.links.carrier == 'electrolysis']\n",
            "            if len(electrolysis) > 0:\n",
            "                # Draw electrolysis links connecting electricity bus to H2 storage\n",
            "                for link_id, link in electrolysis.iterrows():\n",
            "                    # bus0 is electricity input, bus1 is H2 output/storage\n",
            "                    if link.bus0 in bus_coords.index and link.bus1 in bus_coords.index:\n",
            "                        bus0_coords = [bus_coords.loc[link.bus0, 'lat'], bus_coords.loc[link.bus0, 'lon']]\n",
            "                        bus1_coords = [bus_coords.loc[link.bus1, 'lat'], bus_coords.loc[link.bus1, 'lon']]\n",
            "                        folium.PolyLine(\n",
            "                            [bus0_coords, bus1_coords],\n",
            "                            color='#40E0D0',  # Turquoise for electrolysis links\n",
            "                            weight=2,\n",
            "                            opacity=0.6,\n",
            "                            dash_array='5, 5',  # Dashed line\n",
            "                            tooltip=f'Electrolysis Link: {link_id}<br>Capacity: {link.p_nom:.0f} MW'\n",
            "                        ).add_to(m)\n",
            "                \n",
            "                # Draw electrolysis facility markers at electricity input bus\n",
            "                for link_id, link in electrolysis.iterrows():\n",
            "                    if link.bus0 in bus_coords.index:\n",
            "                        coords = bus_coords.loc[link.bus0]\n",
            "                        folium.CircleMarker(\n",
            "                            location=[coords['lat'], coords['lon']],\n",
            "                            radius=6 + (link.p_nom / 500),  # Size by capacity\n",
            "                            color='#40E0D0',  # Turquoise\n",
            "                            fill=True,\n",
            "                            fillColor='#40E0D0',\n",
            "                            fillOpacity=0.7,\n",
            "                            tooltip=f'Electrolysis: {link_id}<br>Capacity: {link.p_nom:.0f} MW<br>Electricity bus: {link.bus0}<br>H2 bus: {link.bus1}'\n",
            "                        ).add_to(m)\n",
            "                print(f'Added {len(electrolysis)} electrolysis units and links to map')\n",
            "        \n",
            "        # 3. Draw H2 turbine locations (H2 -> electricity)\n",
            "        if len(network.links) > 0:\n",
            "            h2_turbines = network.links[network.links.carrier == 'H2_turbine']\n",
            "            if len(h2_turbines) > 0:\n",
            "                for link_id, link in h2_turbines.iterrows():\n",
            "                    # bus1 is electricity output\n",
            "                    if link.bus1 in bus_coords.index:\n",
            "                        coords = bus_coords.loc[link.bus1]\n",
            "                        folium.CircleMarker(\n",
            "                            location=[coords['lat'], coords['lon']],\n",
            "                            radius=6 + (link.p_nom / 500),  # Size by capacity\n",
            "                            color='#FF6347',  # Tomato red\n",
            "                            fill=True,\n",
            "                            fillColor='#FF6347',\n",
            "                            fillOpacity=0.7,\n",
            "                            tooltip=f'H2 Turbine: {link_id}<br>Capacity: {link.p_nom:.0f} MW<br>Bus: {link.bus1}'\n",
            "                        ).add_to(m)\n",
            "                print(f'Added {len(h2_turbines)} H2 turbine units to map')\n",
            "        \n",
            "        # 4. Draw H2 storage locations\n",
            "        if len(network.stores) > 0:\n",
            "            h2_stores = network.stores[network.stores.carrier == 'H2_gas']\n",
            "            if len(h2_stores) > 0:\n",
            "                for store_id, store in h2_stores.iterrows():\n",
            "                    if store.bus in bus_coords.index:\n",
            "                        coords = bus_coords.loc[store.bus]\n",
            "                        energy_gwh = store.e_nom / 1000\n",
            "                        folium.CircleMarker(\n",
            "                            location=[coords['lat'], coords['lon']],\n",
            "                            radius=8,\n",
            "                            color='#9467BD',  # Purple\n",
            "                            fill=True,\n",
            "                            fillColor='#9467BD',\n",
            "                            fillOpacity=0.8,\n",
            "                            tooltip=f'H2 Storage: {store_id}<br>Capacity: {energy_gwh:.1f} GWh<br>Bus: {store.bus}'\n",
            "                        ).add_to(m)\n",
            "                print(f'Added {len(h2_stores)} H2 storage facilities to map')\n",
            "        \n",
            "        # Add legend\n",
            "        legend_html = '''<div style=\\\"position: fixed; bottom: 50px; right: 50px; width: 240px; \n",
            "                         background-color: white; border:2px solid grey; z-index:9999; font-size:14px;\n",
            "                         padding: 10px\\\">\\n",
            "                         <p style=\\\"margin:0; font-weight:bold;\\\">Hydrogen Infrastructure</p>\\n",
            "                         <p style=\\\"margin:5px 0;\\\"><span style=\\\"color:#00CED1; font-size:20px;\\\">━━</span> H2 Pipeline</p>\\n",
            "                         <p style=\\\"margin:5px 0;\\\"><span style=\\\"color:#40E0D0; font-size:12px;\\\">- - -</span> Electrolysis Link</p>\\n",
            "                         <p style=\\\"margin:5px 0;\\\"><span style=\\\"color:#40E0D0; font-size:20px;\\\">●</span> Electrolysis</p>\\n",
            "                         <p style=\\\"margin:5px 0;\\\"><span style=\\\"color:#FF6347; font-size:20px;\\\">●</span> H2 Turbine</p>\\n",
            "                         <p style=\\\"margin:5px 0;\\\"><span style=\\\"color:#9467BD; font-size:20px;\\\">●</span> H2 Storage</p>\\n",
            "                         </div>'''\n",
            "        m.get_root().html.add_child(folium.Element(legend_html))\n",
            "        \n",
            "        display(m)\n",
            "        print('\\\\n✓ Hydrogen network map displayed')\n",
            "        print('Marker size indicates capacity (larger = higher capacity)')\n",
            "    else:\n",
            "        print('No hydrogen infrastructure found or missing bus coordinates')\n",
            "except Exception as e:\n",
            "    print(f'⚠️  Hydrogen network map unavailable: {e}')\n",
            "    import traceback\n",
            "    traceback.print_exc()"
        ]
    })
    
    # Cell 9: Transmission analysis
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Transmission Analysis"
        ]
    })
    
    # Cell 11: Interactive transmission analysis (handles both lines and links)
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive transmission loading analysis with congestion hotspots\n",
            "# Handles both lines (ETYS/Reduced) and links (Zonal)\n",
            "snapshot_idx = len(network.snapshots) // 2\n",
            "snapshot = network.snapshots[snapshot_idx]\n",
            "\n",
            "# Determine which transmission elements to analyze\n",
            "has_lines = len(network.lines) > 0 and 's_nom' in network.lines.columns\n",
            "has_internal_links = len(network.links) > 0\n",
            "\n",
            "if has_lines:\n",
            "    # ETYS/Reduced network - use lines\n",
            "    loading = (network.lines_t.p0.loc[snapshot].abs() / network.lines.s_nom).fillna(0)\n",
            "    components = network.lines\n",
            "    element_type = 'Line'\n",
            "elif has_internal_links:\n",
            "    # Zonal network - use internal links only (exclude external and hydrogen links)\n",
            "    h2_carriers = ['electrolysis', 'H2_turbine', 'H2_power', 'H2', 'H2_gas']\n",
            "    is_external = (\n",
            "        network.links.bus0.str.lower().str.contains('external', na=False) |\n",
            "        network.links.bus1.str.lower().str.contains('external', na=False)\n",
            "    )\n",
            "    is_h2_link = network.links.carrier.isin(h2_carriers)\n",
            "    internal_links = network.links[~is_external & ~is_h2_link]\n",
            "    if len(internal_links) > 0 and snapshot in network.links_t.p0.index:\n",
            "        link_flows = network.links_t.p0.loc[snapshot, internal_links.index].abs()\n",
            "        loading = (link_flows / internal_links.p_nom).fillna(0)\n",
            "        components = internal_links\n",
            "        element_type = 'Link'\n",
            "    else:\n",
            "        loading = pd.Series(dtype=float)\n",
            "        element_type = 'None'\n",
            "else:\n",
            "    loading = pd.Series(dtype=float)\n",
            "    element_type = 'None'\n",
            "\n",
            "if len(loading) > 0:\n",
            "    loading_sorted = loading.sort_values(ascending=False)\n",
            "    top_n = min(20, len(loading_sorted))\n",
            "    top_elements = loading_sorted.head(top_n)\n",
            "    \n",
            "    # Create labels with bus names\n",
            "    element_labels = []\n",
            "    for elem_id in top_elements.index:\n",
            "        bus0 = components.loc[elem_id, 'bus0']\n",
            "        bus1 = components.loc[elem_id, 'bus1']\n",
            "        element_labels.append(f'{bus0} - {bus1}')\n",
            "    \n",
            "    # Color code by congestion level\n",
            "    colors_list = [\n",
            "        '#DC143C' if x >= 0.95 else '#FF8C00' if x >= 0.8 else '#FFD700' if x >= 0.6 else '#228B22'\n",
            "        for x in top_elements.values\n",
            "    ]\n",
            "    \n",
            "    fig = go.Figure()\n",
            "    fig.add_trace(go.Bar(\n",
            "        y=element_labels,\n",
            "        x=top_elements.values * 100,\n",
            "        orientation='h',\n",
            "        marker=dict(color=colors_list),\n",
            "        text=[f'{val*100:.1f}%' for val in top_elements.values],\n",
            "        textposition='auto',\n",
            "        hovertemplate='<b>%{y}</b><br>Loading: %{x:.1f}%<extra></extra>'\n",
            "    ))\n",
            "    \n",
            "    # Add reference lines\n",
            "    fig.add_vline(x=95, line_dash='dash', line_color='red', annotation_text='95% (Congestion)')\n",
            "    fig.add_vline(x=100, line_dash='solid', line_color='darkred', annotation_text='100% (Limit)')\n",
            "    \n",
            "    fig.update_layout(\n",
            "        title=dict(text=f'Top {top_n} Most Loaded {element_type}s - {scenario_id}', x=0.5, xanchor='center'),\n",
            "        xaxis_title=f'{element_type} Loading (%)',\n",
            "        yaxis_title='',\n",
            "        height=max(400, top_n * 25),\n",
            "        template='plotly_white',\n",
            "        showlegend=False\n",
            "    )\n",
            "    fig.show()\n",
            "    \n",
            "    # Statistics\n",
            "    print(f'\\n{element_type} Loading Statistics (snapshot: {snapshot})')\n",
            "    print(f'  Total {element_type.lower()}s: {len(loading)}')\n",
            "    print(f'  Max loading: {loading.max()*100:.1f}%')\n",
            "    print(f'  Mean loading: {loading.mean()*100:.1f}%')\n",
            "    print(f'  {element_type}s >95% loaded: {(loading >= 0.95).sum()}')\n",
            "    print(f'  {element_type}s >80% loaded: {(loading >= 0.80).sum()}')\n",
            "else:\n",
            "    print('No transmission elements found for loading analysis')"
        ]
    })
    
    # Cell 10: Renewable curtailment
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Renewable Curtailment Analysis"
        ]
    })
    
    # Cell 13: Interactive renewable curtailment
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive renewable curtailment analysis\n",
            "renewable_carriers = ['wind_onshore', 'wind_offshore', 'solar_pv']\n",
            "\n",
            "# Create subplots for each renewable carrier\n",
            "fig = make_subplots(\n",
            "    rows=len(renewable_carriers), cols=1,\n",
            "    subplot_titles=[carrier.replace('_', ' ').title() for carrier in renewable_carriers],\n",
            "    vertical_spacing=0.08\n",
            ")\n",
            "\n",
            "curtailment_stats = {}\n",
            "\n",
            "for idx, carrier in enumerate(renewable_carriers, 1):\n",
            "    # Get generators of this carrier\n",
            "    gens = network.generators[network.generators.carrier == carrier]\n",
            "    \n",
            "    if len(gens) == 0:\n",
            "        continue\n",
            "    \n",
            "    # Calculate available and dispatched\n",
            "    p_nom_sum = gens.p_nom.sum()\n",
            "    \n",
            "    # Check if any of these generators have p_max_pu time series data\n",
            "    # p_max_pu columns are indexed by generator name, not carrier\n",
            "    gens_with_pmax = [g for g in gens.index if g in network.generators_t.p_max_pu.columns]\n",
            "    \n",
            "    if len(gens_with_pmax) > 0:\n",
            "        # Calculate available capacity from p_max_pu (weather-dependent availability)\n",
            "        available = network.generators_t.p_max_pu[gens_with_pmax].multiply(\n",
            "            gens.loc[gens_with_pmax, 'p_nom'], axis=1).sum(axis=1)\n",
            "        # Add any generators without p_max_pu at their full capacity\n",
            "        gens_without_pmax = [g for g in gens.index if g not in network.generators_t.p_max_pu.columns]\n",
            "        if len(gens_without_pmax) > 0:\n",
            "            available = available + gens.loc[gens_without_pmax, 'p_nom'].sum()\n",
            "    else:\n",
            "        # No time-varying availability - use installed capacity\n",
            "        available = pd.Series(p_nom_sum, index=network.snapshots)\n",
            "    \n",
            "    dispatched = network.generators_t.p[gens.index].sum(axis=1)\n",
            "    curtailed = available - dispatched\n",
            "    \n",
            "    # Add available capacity trace\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=available.index,\n",
            "            y=available / 1000,\n",
            "            name='Available',\n",
            "            line=dict(color='orange', width=1.5),\n",
            "            legendgroup=carrier,\n",
            "            showlegend=(idx == 1),\n",
            "            hovertemplate='Available: %{y:.2f} GW<extra></extra>'\n",
            "        ),\n",
            "        row=idx, col=1\n",
            "    )\n",
            "    \n",
            "    # Add available capacity trace (orange line showing weather-dependent potential)\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=available.index,\n",
            "            y=available / 1000,\n",
            "            name='Available',\n",
            "            line=dict(color='#FF8C00', width=1.5),\n",
            "            mode='lines',\n",
            "            legendgroup=carrier,\n",
            "            showlegend=(idx == 1),\n",
            "            hovertemplate='Available: %{y:.2f} GW<extra></extra>'\n",
            "        ),\n",
            "        row=idx, col=1\n",
            "    )\n",
            "    \n",
            "    # Add dispatched trace (filled area from zero)\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=dispatched.index,\n",
            "            y=dispatched / 1000,\n",
            "            name='Dispatched',\n",
            "            line=dict(color='#228B22', width=1.5),\n",
            "            fill='tozeroy',\n",
            "            fillcolor='rgba(34, 139, 34, 0.6)',\n",
            "            legendgroup=carrier,\n",
            "            showlegend=(idx == 1),\n",
            "            hovertemplate='Dispatched: %{y:.2f} GW<extra></extra>'\n",
            "        ),\n",
            "        row=idx, col=1\n",
            "    )\n",
            "    \n",
            "    # Add curtailed as separate trace showing actual curtailment\n",
            "    curtailed_positive = curtailed.clip(lower=0)  # Only show positive curtailment\n",
            "    fig.add_trace(\n",
            "        go.Scatter(\n",
            "            x=curtailed_positive.index,\n",
            "            y=curtailed_positive / 1000,\n",
            "            name='Curtailed',\n",
            "            line=dict(color='#DC143C', width=1.5, dash='dot'),\n",
            "            mode='lines',\n",
            "            legendgroup=carrier,\n",
            "            showlegend=(idx == 1),\n",
            "            hovertemplate='Curtailed: %{y:.2f} GW<extra></extra>'\n",
            "        ),\n",
            "        row=idx, col=1\n",
            "    )\n",
            "    \n",
            "    # Update y-axis label\n",
            "    fig.update_yaxes(title_text='Power (GW)', row=idx, col=1)\n",
            "    \n",
            "    # Calculate statistics\n",
            "    curtailment_pct = (curtailed.sum() / available.sum() * 100) if available.sum() > 0 else 0\n",
            "    capacity_factor = (dispatched.sum() / (p_nom_sum * len(network.snapshots)) * 100)\n",
            "    \n",
            "    curtailment_stats[carrier] = {\n",
            "        'capacity_mw': p_nom_sum,\n",
            "        'available_mwh': available.sum(),\n",
            "        'dispatched_mwh': dispatched.sum(),\n",
            "        'curtailed_mwh': curtailed.sum(),\n",
            "        'curtailment_pct': curtailment_pct,\n",
            "        'capacity_factor': capacity_factor\n",
            "    }\n",
            "\n",
            "# Update layout\n",
            "fig.update_xaxes(title_text='Time', row=len(renewable_carriers), col=1)\n",
            "fig.update_layout(\n",
            "    title=dict(text='Renewable Curtailment Analysis - " + scenario_id + "', x=0.5, xanchor='center'),\n",
            "    height=900,\n",
            "    hovermode='x unified',\n",
            "    template='plotly_white'\n",
            ")\n",
            "\n",
            "fig.show()\n",
            "\n",
            "# Print statistics\n",
            "print('\\nRenewable Curtailment Statistics:')\n",
            "print('=' * 80)\n",
            "for carrier, stats in curtailment_stats.items():\n",
            "    print(f\"\\n{carrier.replace('_', ' ').title()}:\")\n",
            "    print(f\"  Installed Capacity: {stats['capacity_mw']:,.0f} MW\")\n",
            "    print(f\"  Available Energy: {stats['available_mwh']:,.0f} MWh\")\n",
            "    print(f\"  Dispatched Energy: {stats['dispatched_mwh']:,.0f} MWh\")\n",
            "    print(f\"  Curtailed Energy: {stats['curtailed_mwh']:,.0f} MWh ({stats['curtailment_pct']:.1f}%)\")\n",
            "    print(f\"  Capacity Factor: {stats['capacity_factor']:.1f}%\")"
        ]
    })

    # Cell 14b: Demand flexibility usage
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Demand Flexibility Usage\n",
            "\n",
            "Check how heat pumps, EVs, and demand response are used in the solved network."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "import pandas as pd\n",
            "\n",
            "def _snapshot_weights(n):\n",
            "    if hasattr(n, 'snapshot_weightings') and n.snapshot_weightings is not None and len(n.snapshot_weightings) > 0:\n",
            "        if 'objective' in n.snapshot_weightings.columns:\n",
            "            return n.snapshot_weightings['objective']\n",
            "        return n.snapshot_weightings.iloc[:, 0]\n",
            "    if len(n.snapshots) > 1:\n",
            "        dt_hours = (n.snapshots[1] - n.snapshots[0]).total_seconds() / 3600\n",
            "    else:\n",
            "        dt_hours = 1.0\n",
            "    return pd.Series(dt_hours, index=n.snapshots)\n",
            "\n",
            "weights = _snapshot_weights(network)\n",
            "total_hours = weights.sum()\n",
            "\n",
            "def _energy_mwh(ts):\n",
            "    if ts is None or ts.empty:\n",
            "        return 0.0\n",
            "    return ts.mul(weights, axis=0).sum().sum()\n",
            "\n",
            "def _active_count(ts, tol=1e-6):\n",
            "    if ts is None or ts.empty:\n",
            "        return 0\n",
            "    return int((ts.abs().max(axis=0) > tol).sum())\n",
            "\n",
            "print('DEMAND FLEXIBILITY USAGE')\n",
            "print('=' * 80)\n",
            "\n",
            "# Heat pumps\n",
            "hp_links = network.links[network.links.carrier == 'heat pump']\n",
            "hp_link_ts = network.links_t.p0[hp_links.index] if len(hp_links) > 0 else pd.DataFrame()\n",
            "hp_loads = network.loads[network.loads.carrier.isin(['hot water demand', 'space heating'])]\n",
            "hp_load_ts = network.loads_t.p_set[hp_loads.index] if len(hp_loads) > 0 else pd.DataFrame()\n",
            "hp_stores = network.stores[network.stores.carrier.isin(['hot water', 'thermal inertia'])]\n",
            "hp_store_ts = network.stores_t.p[hp_stores.index] if len(hp_stores) > 0 and hasattr(network, 'stores_t') else pd.DataFrame()\n",
            "\n",
            "hp_electric_mwh = _energy_mwh(hp_link_ts.abs())\n",
            "hp_thermal_mwh = _energy_mwh(hp_load_ts)\n",
            "hp_capacity_mw = hp_links.p_nom.sum() if len(hp_links) > 0 else 0.0\n",
            "hp_cf = (hp_electric_mwh / (hp_capacity_mw * total_hours)) if hp_capacity_mw > 0 and total_hours > 0 else 0.0\n",
            "\n",
            "print('Heat pumps:')\n",
            "print(f\"  Links: {len(hp_links)} (active: {_active_count(hp_link_ts)})\")\n",
            "print(f\"  Stores: {len(hp_stores)} (active: {_active_count(hp_store_ts)})\")\n",
            "print(f\"  Thermal loads: {len(hp_loads)}\")\n",
            "print(f\"  Electric input: {hp_electric_mwh:,.0f} MWh\")\n",
            "print(f\"  Thermal demand: {hp_thermal_mwh:,.0f} MWh\")\n",
            "print(f\"  Capacity factor (electric): {hp_cf*100:.1f}%\")\n",
            "print()\n",
            "\n",
            "# EV flexibility\n",
            "ev_chargers = network.links[network.links.carrier == 'EV charger']\n",
            "ev_v2g = network.links[network.links.carrier == 'V2G']\n",
            "ev_charger_ts = network.links_t.p0[ev_chargers.index] if len(ev_chargers) > 0 else pd.DataFrame()\n",
            "ev_v2g_ts = network.links_t.p1[ev_v2g.index] if len(ev_v2g) > 0 else pd.DataFrame()\n",
            "ev_stores = network.stores[network.stores.carrier == 'EV battery']\n",
            "ev_store_ts = network.stores_t.p[ev_stores.index] if len(ev_stores) > 0 and hasattr(network, 'stores_t') else pd.DataFrame()\n",
            "ev_loads = network.loads[network.loads.carrier == 'EV driving']\n",
            "ev_load_ts = network.loads_t.p_set[ev_loads.index] if len(ev_loads) > 0 else pd.DataFrame()\n",
            "\n",
            "ev_charge_mwh = _energy_mwh(ev_charger_ts.clip(lower=0))\n",
            "ev_v2g_mwh = _energy_mwh(ev_v2g_ts.clip(lower=0))\n",
            "ev_drive_mwh = _energy_mwh(ev_load_ts)\n",
            "\n",
            "print('Electric vehicles:')\n",
            "print(f\"  Chargers: {len(ev_chargers)} (active: {_active_count(ev_charger_ts)})\")\n",
            "print(f\"  V2G links: {len(ev_v2g)} (active: {_active_count(ev_v2g_ts)})\")\n",
            "print(f\"  Stores: {len(ev_stores)} (active: {_active_count(ev_store_ts)})\")\n",
            "print(f\"  Driving loads: {len(ev_loads)}\")\n",
            "print(f\"  Grid charge energy: {ev_charge_mwh:,.0f} MWh\")\n",
            "print(f\"  V2G export energy: {ev_v2g_mwh:,.0f} MWh\")\n",
            "print(f\"  Driving demand energy: {ev_drive_mwh:,.0f} MWh\")\n",
            "print()\n",
            "\n",
            "# Event response / demand response\n",
            "dr_gens = network.generators[network.generators.carrier == 'demand response']\n",
            "dr_ts = network.generators_t.p[dr_gens.index] if len(dr_gens) > 0 else pd.DataFrame()\n",
            "dr_energy_mwh = _energy_mwh(dr_ts.clip(lower=0))\n",
            "\n",
            "print('Demand response events:')\n",
            "print(f\"  Generators: {len(dr_gens)} (active: {_active_count(dr_ts)})\")\n",
            "print(f\"  Event energy: {dr_energy_mwh:,.0f} MWh\")\n",
            "print('=' * 80)\n"
        ]
    })

    # Cell 14c: Demand flexibility time series
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Demand Flexibility Time Series\n",
            "\n",
            "Plot total utilization over time for heat pumps, EV charging, V2G export, and demand response."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "import pandas as pd\n",
            "\n",
            "hp_links = network.links[network.links.carrier == 'heat pump']\n",
            "hp_ts = network.links_t.p0[hp_links.index].abs().sum(axis=1) if len(hp_links) > 0 else pd.Series(0.0, index=network.snapshots)\n",
            "\n",
            "ev_chargers = network.links[network.links.carrier == 'EV charger']\n",
            "ev_charge_ts = network.links_t.p0[ev_chargers.index].clip(lower=0).sum(axis=1) if len(ev_chargers) > 0 else pd.Series(0.0, index=network.snapshots)\n",
            "\n",
            "ev_v2g = network.links[network.links.carrier == 'V2G']\n",
            "ev_v2g_ts = network.links_t.p1[ev_v2g.index].clip(lower=0).sum(axis=1) if len(ev_v2g) > 0 else pd.Series(0.0, index=network.snapshots)\n",
            "\n",
            "dr_gens = network.generators[network.generators.carrier == 'demand response']\n",
            "dr_ts = network.generators_t.p[dr_gens.index].clip(lower=0).sum(axis=1) if len(dr_gens) > 0 else pd.Series(0.0, index=network.snapshots)\n",
            "\n",
            "ts_df = pd.DataFrame({\n",
            "    'Heat pumps (electric input)': hp_ts,\n",
            "    'EV charging': ev_charge_ts,\n",
            "    'V2G export': ev_v2g_ts,\n",
            "    'Demand response': dr_ts,\n",
            "})\n",
            "ts_df = ts_df.loc[:, (ts_df != 0).any(axis=0)]\n",
            "\n",
            "if ts_df.empty:\n",
            "    print('No demand flexibility time series found')\n",
            "else:\n",
            "    fig = go.Figure()\n",
            "    colors = ['#1f77b4', '#2ca02c', '#ff7f0e', '#9467bd']\n",
            "    for i, col in enumerate(ts_df.columns):\n",
            "        fig.add_trace(go.Scatter(\n",
            "            x=ts_df.index,\n",
            "            y=ts_df[col] / 1000,\n",
            "            name=col,\n",
            "            mode='lines',\n",
            "            line=dict(width=1.5, color=colors[i % len(colors)]),\n",
            "            hovertemplate='Time: %{x}<br>Power: %{y:.2f} GW<extra></extra>'\n",
            "        ))\n",
            "    fig.update_layout(\n",
            "        title='Demand Flexibility Utilization',\n",
            "        xaxis_title='Time',\n",
            "        yaxis_title='Power (GW)',\n",
            "        hovermode='x unified',\n",
            "        template='plotly_white',\n",
            "        height=400\n",
            "    )\n",
            "    fig.show()\n"
        ]
    })

    # Cell 14d: Demand flexibility spatial distribution
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Demand Flexibility Spatial Distribution\n",
            "\n",
            "Map heat pump, EV, and demand response capacity by bus."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "import folium\n",
            "from folium import FeatureGroup, LayerControl\n",
            "\n",
            "if 'x' not in network.buses.columns or 'y' not in network.buses.columns:\n",
            "    print('No bus coordinates available for mapping')\n",
            "else:\n",
            "    bus_x = network.buses['x'].astype(float)\n",
            "    bus_y = network.buses['y'].astype(float)\n",
            "    if bus_x.max() > 100 or bus_y.max() > 100:\n",
            "        t = Transformer.from_crs('EPSG:27700', 'EPSG:4326', always_xy=True)\n",
            "        lon, lat = t.transform(bus_x.to_numpy(), bus_y.to_numpy())\n",
            "    else:\n",
            "        lon, lat = bus_x.to_numpy(), bus_y.to_numpy()\n",
            "    bus_coords = pd.DataFrame({'lon': lon, 'lat': lat}, index=network.buses.index).dropna()\n",
            "\n",
            "    hp_links = network.links[network.links.carrier == 'heat pump']\n",
            "    ev_chargers = network.links[network.links.carrier == 'EV charger']\n",
            "    dr_gens = network.generators[network.generators.carrier == 'demand response']\n",
            "\n",
            "    hp_by_bus = hp_links.groupby('bus0')['p_nom'].sum() if len(hp_links) > 0 else pd.Series(dtype=float)\n",
            "    ev_by_bus = ev_chargers.groupby('bus0')['p_nom'].sum() if len(ev_chargers) > 0 else pd.Series(dtype=float)\n",
            "    dr_by_bus = dr_gens.groupby('bus')['p_nom'].sum() if len(dr_gens) > 0 else pd.Series(dtype=float)\n",
            "\n",
            "    if hp_by_bus.empty and ev_by_bus.empty and dr_by_bus.empty:\n",
            "        print('No demand flexibility components found for mapping')\n",
            "    else:\n",
            "        center_lat = bus_coords['lat'].mean()\n",
            "        center_lon = bus_coords['lon'].mean()\n",
            "        m = folium.Map(location=[center_lat, center_lon], zoom_start=5, tiles='CartoDB positron')\n",
            "\n",
            "        def add_layer(series, color, label):\n",
            "            if series.empty:\n",
            "                return\n",
            "            series = series[series > 0]\n",
            "            if series.empty:\n",
            "                return\n",
            "            max_cap = series.max()\n",
            "            fg = FeatureGroup(name=label)\n",
            "            for bus, cap in series.items():\n",
            "                if bus not in bus_coords.index:\n",
            "                    continue\n",
            "                coords = bus_coords.loc[bus]\n",
            "                radius = 2 + 8 * (cap / max_cap) ** 0.5\n",
            "                tooltip = f\"{label} - {bus}: {cap:.1f} MW\"\n",
            "                folium.CircleMarker(\n",
            "                    location=[coords['lat'], coords['lon']],\n",
            "                    radius=radius,\n",
            "                    color=color,\n",
            "                    fill=True,\n",
            "                    fill_opacity=0.7,\n",
            "                    weight=1,\n",
            "                    tooltip=tooltip,\n",
            "                ).add_to(fg)\n",
            "            fg.add_to(m)\n",
            "\n",
            "        add_layer(hp_by_bus, '#d62728', 'Heat pumps')\n",
            "        add_layer(ev_by_bus, '#1f77b4', 'EV chargers')\n",
            "        add_layer(dr_by_bus, '#9467bd', 'Demand response')\n",
            "\n",
            "        LayerControl().add_to(m)\n",
            "        m\n"
        ]
    })

    # Cell 14e: Heat Pump Flexibility Detailed Analysis
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Heat Pump Flexibility - Detailed Analysis\n",
            "\n",
            "Breakdown of heat pump TANK (hot water) vs COSY (thermal inertia) flexibility,\n",
            "including store utilization and thermal demand served."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Heat pump flexibility detailed breakdown\n",
            "hp_links = network.links[network.links.carrier == 'heat pump']\n",
            "hp_tank_links = hp_links[hp_links.index.str.contains('tank', case=False)]\n",
            "hp_cosy_links = hp_links[~hp_links.index.str.contains('tank', case=False)]\n",
            "\n",
            "# Thermal stores\n",
            "hw_stores = network.stores[network.stores.carrier == 'hot water']\n",
            "ti_stores = network.stores[network.stores.carrier == 'thermal inertia']\n",
            "\n",
            "# Thermal loads\n",
            "hw_loads = network.loads[network.loads.carrier == 'hot water demand']\n",
            "sh_loads = network.loads[network.loads.carrier == 'space heating']\n",
            "\n",
            "if len(hp_links) == 0:\n",
            "    print('No heat pump flexibility components found in network')\n",
            "else:\n",
            "    print('HEAT PUMP FLEXIBILITY BREAKDOWN')\n",
            "    print('=' * 60)\n",
            "    \n",
            "    # TANK mode\n",
            "    print('\\n--- TANK Mode (Hot Water Storage) ---')\n",
            "    print(f'HP tank links: {len(hp_tank_links)}')\n",
            "    print(f'Hot water stores: {len(hw_stores)}')\n",
            "    print(f'Hot water loads: {len(hw_loads)}')\n",
            "    if len(hp_tank_links) > 0:\n",
            "        tank_pnom = hp_tank_links.p_nom.sum()\n",
            "        tank_cols = [c for c in hp_tank_links.index if c in network.links_t.p0.columns]\n",
            "        tank_elec = network.links_t.p0[tank_cols].sum().sum() if tank_cols else 0\n",
            "        print(f'Total capacity: {tank_pnom:,.1f} MW (electric)')\n",
            "        print(f'Total electricity consumed: {tank_elec:,.0f} MWh')\n",
            "    if len(hw_stores) > 0:\n",
            "        print(f'Total store capacity: {hw_stores.e_nom.sum():,.1f} MWh')\n",
            "    if len(hw_loads) > 0:\n",
            "        hw_cols = [c for c in hw_loads.index if c in network.loads_t.p_set.columns]\n",
            "        hw_demand = network.loads_t.p_set[hw_cols].sum().sum() if hw_cols else 0\n",
            "        print(f'Total hot water demand: {hw_demand:,.0f} MWh')\n",
            "    \n",
            "    # COSY mode\n",
            "    print('\\n--- COSY Mode (Thermal Inertia) ---')\n",
            "    print(f'HP COSY links: {len(hp_cosy_links)}')\n",
            "    print(f'Thermal inertia stores: {len(ti_stores)}')\n",
            "    print(f'Space heating loads: {len(sh_loads)}')\n",
            "    if len(hp_cosy_links) > 0:\n",
            "        cosy_pnom = hp_cosy_links.p_nom.sum()\n",
            "        cosy_cols = [c for c in hp_cosy_links.index if c in network.links_t.p0.columns]\n",
            "        cosy_elec = network.links_t.p0[cosy_cols].sum().sum() if cosy_cols else 0\n",
            "        print(f'Total capacity: {cosy_pnom:,.1f} MW (electric)')\n",
            "        print(f'Total electricity consumed: {cosy_elec:,.0f} MWh')\n",
            "    if len(ti_stores) > 0:\n",
            "        print(f'Total store capacity: {ti_stores.e_nom.sum():,.1f} MWh')\n",
            "    if len(sh_loads) > 0:\n",
            "        sh_cols = [c for c in sh_loads.index if c in network.loads_t.p_set.columns]\n",
            "        sh_demand = network.loads_t.p_set[sh_cols].sum().sum() if sh_cols else 0\n",
            "        print(f'Total space heating demand: {sh_demand:,.0f} MWh')\n",
            "    \n",
            "    # Check for load shedding on heat/thermal buses\n",
            "    heat_buses = network.buses[network.buses.carrier == 'heat']\n",
            "    thermal_buses = network.buses[network.buses.carrier == 'thermal inertia']\n",
            "    ls_gens = network.generators[network.generators.carrier == 'load_shedding']\n",
            "    heat_ls = ls_gens[ls_gens.bus.isin(heat_buses.index)]\n",
            "    thermal_ls = ls_gens[ls_gens.bus.isin(thermal_buses.index)]\n",
            "    \n",
            "    print('\\n--- Load Shedding Check ---')\n",
            "    if len(heat_ls) > 0:\n",
            "        heat_ls_cols = [c for c in heat_ls.index if c in network.generators_t.p.columns]\n",
            "        heat_ls_total = network.generators_t.p[heat_ls_cols].sum().sum() if heat_ls_cols else 0\n",
            "        print(f'Heat bus load shedding: {heat_ls_total:,.2f} MWh')\n",
            "    if len(thermal_ls) > 0:\n",
            "        thermal_ls_cols = [c for c in thermal_ls.index if c in network.generators_t.p.columns]\n",
            "        thermal_ls_total = network.generators_t.p[thermal_ls_cols].sum().sum() if thermal_ls_cols else 0\n",
            "        print(f'Thermal inertia bus load shedding: {thermal_ls_total:,.2f} MWh')\n"
        ]
    })

    # Cell 14f: Heat Pump Time Series Visualization
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Heat pump flexibility time series - TANK vs COSY\n",
            "hp_links = network.links[network.links.carrier == 'heat pump']\n",
            "hp_tank_links = hp_links[hp_links.index.str.contains('tank', case=False)]\n",
            "hp_cosy_links = hp_links[~hp_links.index.str.contains('tank', case=False)]\n",
            "\n",
            "if len(hp_links) == 0:\n",
            "    print('No heat pump links found')\n",
            "else:\n",
            "    tank_cols = [c for c in hp_tank_links.index if c in network.links_t.p0.columns]\n",
            "    cosy_cols = [c for c in hp_cosy_links.index if c in network.links_t.p0.columns]\n",
            "    \n",
            "    tank_ts = network.links_t.p0[tank_cols].sum(axis=1) if tank_cols else pd.Series(0, index=network.snapshots)\n",
            "    cosy_ts = network.links_t.p0[cosy_cols].sum(axis=1) if cosy_cols else pd.Series(0, index=network.snapshots)\n",
            "    \n",
            "    # Get thermal demand\n",
            "    hw_loads = network.loads[network.loads.carrier == 'hot water demand']\n",
            "    sh_loads = network.loads[network.loads.carrier == 'space heating']\n",
            "    hw_cols = [c for c in hw_loads.index if c in network.loads_t.p_set.columns]\n",
            "    sh_cols = [c for c in sh_loads.index if c in network.loads_t.p_set.columns]\n",
            "    hw_demand_ts = network.loads_t.p_set[hw_cols].sum(axis=1) if hw_cols else pd.Series(0, index=network.snapshots)\n",
            "    sh_demand_ts = network.loads_t.p_set[sh_cols].sum(axis=1) if sh_cols else pd.Series(0, index=network.snapshots)\n",
            "    \n",
            "    fig = make_subplots(rows=2, cols=1, shared_xaxes=True,\n",
            "                        subplot_titles=['Heat Pump Electric Consumption', 'Thermal Demand'],\n",
            "                        vertical_spacing=0.1)\n",
            "    \n",
            "    # Electric consumption\n",
            "    if tank_ts.abs().sum() > 0:\n",
            "        fig.add_trace(go.Scatter(x=tank_ts.index, y=tank_ts/1000, name='HP Tank (electric)',\n",
            "                                 line=dict(color='#1f77b4'), fill='tozeroy'), row=1, col=1)\n",
            "    if cosy_ts.abs().sum() > 0:\n",
            "        fig.add_trace(go.Scatter(x=cosy_ts.index, y=cosy_ts/1000, name='HP COSY (electric)',\n",
            "                                 line=dict(color='#ff7f0e'), fill='tozeroy'), row=1, col=1)\n",
            "    \n",
            "    # Thermal demand\n",
            "    if hw_demand_ts.abs().sum() > 0:\n",
            "        fig.add_trace(go.Scatter(x=hw_demand_ts.index, y=hw_demand_ts/1000, name='Hot Water Demand',\n",
            "                                 line=dict(color='#d62728')), row=2, col=1)\n",
            "    if sh_demand_ts.abs().sum() > 0:\n",
            "        fig.add_trace(go.Scatter(x=sh_demand_ts.index, y=sh_demand_ts/1000, name='Space Heating Demand',\n",
            "                                 line=dict(color='#9467bd')), row=2, col=1)\n",
            "    \n",
            "    fig.update_yaxes(title_text='Power (GW)', row=1, col=1)\n",
            "    fig.update_yaxes(title_text='Power (GW)', row=2, col=1)\n",
            "    fig.update_xaxes(title_text='Time', row=2, col=1)\n",
            "    fig.update_layout(title='Heat Pump Flexibility Operation', template='plotly_white',\n",
            "                      height=600, hovermode='x unified')\n",
            "    fig.show()\n"
        ]
    })

    # Cell 14g: Thermal Store State of Charge
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Thermal store state of charge\n",
            "hw_stores = network.stores[network.stores.carrier == 'hot water']\n",
            "ti_stores = network.stores[network.stores.carrier == 'thermal inertia']\n",
            "\n",
            "has_hw = len(hw_stores) > 0 and 'e' in network.stores_t\n",
            "has_ti = len(ti_stores) > 0 and 'e' in network.stores_t\n",
            "\n",
            "if not has_hw and not has_ti:\n",
            "    print('No thermal store data found')\n",
            "else:\n",
            "    fig = make_subplots(rows=2, cols=1, shared_xaxes=True,\n",
            "                        subplot_titles=['Hot Water Tank SOC (aggregated)', 'Thermal Inertia SOC (aggregated)'],\n",
            "                        vertical_spacing=0.1)\n",
            "    \n",
            "    if has_hw:\n",
            "        hw_cols = [c for c in hw_stores.index if c in network.stores_t.e.columns]\n",
            "        if hw_cols:\n",
            "            hw_soc = network.stores_t.e[hw_cols].sum(axis=1)\n",
            "            fig.add_trace(go.Scatter(x=hw_soc.index, y=hw_soc, name='Hot Water SOC',\n",
            "                                     line=dict(color='#1f77b4'), fill='tozeroy'), row=1, col=1)\n",
            "    \n",
            "    if has_ti:\n",
            "        ti_cols = [c for c in ti_stores.index if c in network.stores_t.e.columns]\n",
            "        if ti_cols:\n",
            "            ti_soc = network.stores_t.e[ti_cols].sum(axis=1)\n",
            "            fig.add_trace(go.Scatter(x=ti_soc.index, y=ti_soc, name='Thermal Inertia SOC',\n",
            "                                     line=dict(color='#ff7f0e'), fill='tozeroy'), row=2, col=1)\n",
            "    \n",
            "    fig.update_yaxes(title_text='Energy (MWh)', row=1, col=1)\n",
            "    fig.update_yaxes(title_text='Energy (MWh)', row=2, col=1)\n",
            "    fig.update_xaxes(title_text='Time', row=2, col=1)\n",
            "    fig.update_layout(title='Thermal Store State of Charge', template='plotly_white',\n",
            "                      height=500, hovermode='x unified')\n",
            "    fig.show()\n"
        ]
    })

    # Cell 14h: EV Flexibility Detailed Analysis
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Electric Vehicle Flexibility - Detailed Analysis\n",
            "\n",
            "Breakdown of EV charging patterns, V2G discharge, and battery state of charge."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# EV flexibility detailed breakdown\n",
            "ev_chargers = network.links[network.links.carrier == 'EV charger']\n",
            "ev_v2g = network.links[network.links.carrier == 'V2G']\n",
            "ev_stores = network.stores[network.stores.carrier == 'EV battery']\n",
            "ev_loads = network.loads[network.loads.carrier == 'EV driving']\n",
            "\n",
            "if len(ev_chargers) == 0 and len(ev_stores) == 0:\n",
            "    print('No EV flexibility components found in network')\n",
            "else:\n",
            "    print('ELECTRIC VEHICLE FLEXIBILITY BREAKDOWN')\n",
            "    print('=' * 60)\n",
            "    \n",
            "    print(f'\\nEV charger links: {len(ev_chargers)}')\n",
            "    print(f'V2G links: {len(ev_v2g)}')\n",
            "    print(f'EV battery stores: {len(ev_stores)}')\n",
            "    print(f'EV driving loads: {len(ev_loads)}')\n",
            "    \n",
            "    if len(ev_chargers) > 0:\n",
            "        charger_pnom = ev_chargers.p_nom.sum()\n",
            "        charger_cols = [c for c in ev_chargers.index if c in network.links_t.p0.columns]\n",
            "        charge_energy = network.links_t.p0[charger_cols].clip(lower=0).sum().sum() if charger_cols else 0\n",
            "        print(f'\\nCharging capacity: {charger_pnom:,.1f} MW')\n",
            "        print(f'Total charging energy: {charge_energy:,.0f} MWh')\n",
            "    \n",
            "    if len(ev_v2g) > 0:\n",
            "        v2g_pnom = ev_v2g.p_nom.sum()\n",
            "        v2g_cols = [c for c in ev_v2g.index if c in network.links_t.p1.columns]\n",
            "        v2g_energy = network.links_t.p1[v2g_cols].clip(lower=0).sum().sum() if v2g_cols else 0\n",
            "        print(f'\\nV2G capacity: {v2g_pnom:,.1f} MW')\n",
            "        print(f'Total V2G discharge energy: {v2g_energy:,.0f} MWh')\n",
            "    \n",
            "    if len(ev_stores) > 0:\n",
            "        store_capacity = ev_stores.e_nom.sum()\n",
            "        print(f'\\nTotal battery capacity: {store_capacity:,.1f} MWh')\n",
            "    \n",
            "    if len(ev_loads) > 0:\n",
            "        ev_load_cols = [c for c in ev_loads.index if c in network.loads_t.p_set.columns]\n",
            "        driving_demand = network.loads_t.p_set[ev_load_cols].sum().sum() if ev_load_cols else 0\n",
            "        print(f'\\nTotal driving demand: {driving_demand:,.0f} MWh')\n"
        ]
    })

    # Cell 14i: EV Time Series Visualization
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# EV flexibility time series\n",
            "ev_chargers = network.links[network.links.carrier == 'EV charger']\n",
            "ev_v2g = network.links[network.links.carrier == 'V2G']\n",
            "ev_stores = network.stores[network.stores.carrier == 'EV battery']\n",
            "ev_loads = network.loads[network.loads.carrier == 'EV driving']\n",
            "\n",
            "has_ev = len(ev_chargers) > 0 or len(ev_stores) > 0\n",
            "\n",
            "if not has_ev:\n",
            "    print('No EV flexibility data to plot')\n",
            "else:\n",
            "    fig = make_subplots(rows=2, cols=1, shared_xaxes=True,\n",
            "                        subplot_titles=['EV Charging & V2G Power', 'EV Battery State of Charge'],\n",
            "                        vertical_spacing=0.1)\n",
            "    \n",
            "    # Charging and V2G\n",
            "    charger_cols = [c for c in ev_chargers.index if c in network.links_t.p0.columns]\n",
            "    v2g_cols = [c for c in ev_v2g.index if c in network.links_t.p1.columns]\n",
            "    \n",
            "    if charger_cols:\n",
            "        charge_ts = network.links_t.p0[charger_cols].sum(axis=1)\n",
            "        fig.add_trace(go.Scatter(x=charge_ts.index, y=charge_ts/1000, name='EV Charging',\n",
            "                                 line=dict(color='#2ca02c'), fill='tozeroy'), row=1, col=1)\n",
            "    \n",
            "    if v2g_cols:\n",
            "        v2g_ts = network.links_t.p1[v2g_cols].sum(axis=1)\n",
            "        # V2G discharge is positive at bus1 (grid)\n",
            "        fig.add_trace(go.Scatter(x=v2g_ts.index, y=-v2g_ts/1000, name='V2G Discharge',\n",
            "                                 line=dict(color='#d62728'), fill='tozeroy'), row=1, col=1)\n",
            "    \n",
            "    # Driving demand\n",
            "    ev_load_cols = [c for c in ev_loads.index if c in network.loads_t.p_set.columns]\n",
            "    if ev_load_cols:\n",
            "        drive_ts = network.loads_t.p_set[ev_load_cols].sum(axis=1)\n",
            "        fig.add_trace(go.Scatter(x=drive_ts.index, y=drive_ts/1000, name='Driving Demand',\n",
            "                                 line=dict(color='#ff7f0e', dash='dash')), row=1, col=1)\n",
            "    \n",
            "    # Battery SOC\n",
            "    if len(ev_stores) > 0 and 'e' in network.stores_t:\n",
            "        ev_store_cols = [c for c in ev_stores.index if c in network.stores_t.e.columns]\n",
            "        if ev_store_cols:\n",
            "            ev_soc = network.stores_t.e[ev_store_cols].sum(axis=1)\n",
            "            fig.add_trace(go.Scatter(x=ev_soc.index, y=ev_soc/1000, name='Battery SOC',\n",
            "                                     line=dict(color='#1f77b4'), fill='tozeroy'), row=2, col=1)\n",
            "    \n",
            "    fig.update_yaxes(title_text='Power (GW)', row=1, col=1)\n",
            "    fig.update_yaxes(title_text='Energy (GWh)', row=2, col=1)\n",
            "    fig.update_xaxes(title_text='Time', row=2, col=1)\n",
            "    fig.update_layout(title='Electric Vehicle Flexibility Operation', template='plotly_white',\n",
            "                      height=600, hovermode='x unified')\n",
            "    fig.show()\n"
        ]
    })

    # Cell 14j: Demand Response / Event Flexibility Analysis
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Demand Response / Event Flexibility - Detailed Analysis\n",
            "\n",
            "Analysis of demand response events (e.g., Saving Sessions style flexibility)."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Demand response / event flexibility analysis\n",
            "dr_gens = network.generators[network.generators.carrier == 'demand response']\n",
            "\n",
            "if len(dr_gens) == 0:\n",
            "    print('No demand response generators found in network')\n",
            "else:\n",
            "    print('DEMAND RESPONSE / EVENT FLEXIBILITY BREAKDOWN')\n",
            "    print('=' * 60)\n",
            "    \n",
            "    print(f'\\nDemand response generators: {len(dr_gens)}')\n",
            "    dr_pnom = dr_gens.p_nom.sum()\n",
            "    print(f'Total capacity: {dr_pnom:,.1f} MW')\n",
            "    \n",
            "    dr_cols = [c for c in dr_gens.index if c in network.generators_t.p.columns]\n",
            "    if dr_cols:\n",
            "        dr_dispatch = network.generators_t.p[dr_cols]\n",
            "        dr_energy = dr_dispatch.sum().sum()\n",
            "        dr_hours = (dr_dispatch.sum(axis=1) > 0.01).sum()\n",
            "        dr_peak = dr_dispatch.sum(axis=1).max()\n",
            "        \n",
            "        print(f'Total event energy: {dr_energy:,.0f} MWh')\n",
            "        print(f'Hours with DR active: {dr_hours}')\n",
            "        print(f'Peak DR dispatch: {dr_peak:,.1f} MW')\n",
            "        \n",
            "        if dr_pnom > 0:\n",
            "            utilization = dr_energy / (dr_pnom * len(network.snapshots)) * 100\n",
            "            print(f'Capacity utilization: {utilization:.2f}%')\n",
            "    \n",
            "    # Marginal cost check\n",
            "    if 'marginal_cost' in dr_gens.columns:\n",
            "        mc = dr_gens.marginal_cost.mean()\n",
            "        print(f'\\nAverage marginal cost: {mc:.2f} GBP/MWh')\n"
        ]
    })

    # Cell 14k: Demand Response Time Series
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Demand response time series visualization\n",
            "dr_gens = network.generators[network.generators.carrier == 'demand response']\n",
            "\n",
            "if len(dr_gens) == 0:\n",
            "    print('No demand response data to plot')\n",
            "else:\n",
            "    dr_cols = [c for c in dr_gens.index if c in network.generators_t.p.columns]\n",
            "    if not dr_cols:\n",
            "        print('No demand response dispatch data')\n",
            "    else:\n",
            "        dr_ts = network.generators_t.p[dr_cols].sum(axis=1)\n",
            "        \n",
            "        # Also get total demand and price for context\n",
            "        total_demand = network.loads_t.p_set.sum(axis=1)\n",
            "        \n",
            "        fig = make_subplots(rows=2, cols=1, shared_xaxes=True,\n",
            "                            subplot_titles=['Demand Response Dispatch', 'Total System Demand'],\n",
            "                            vertical_spacing=0.1)\n",
            "        \n",
            "        fig.add_trace(go.Bar(x=dr_ts.index, y=dr_ts/1000, name='DR Dispatch',\n",
            "                             marker_color='#9467bd'), row=1, col=1)\n",
            "        \n",
            "        fig.add_trace(go.Scatter(x=total_demand.index, y=total_demand/1000, name='Total Demand',\n",
            "                                 line=dict(color='#1f77b4')), row=2, col=1)\n",
            "        \n",
            "        fig.update_yaxes(title_text='Power (GW)', row=1, col=1)\n",
            "        fig.update_yaxes(title_text='Power (GW)', row=2, col=1)\n",
            "        fig.update_xaxes(title_text='Time', row=2, col=1)\n",
            "        fig.update_layout(title='Demand Response Events', template='plotly_white',\n",
            "                          height=500, hovermode='x unified')\n",
            "        fig.show()\n",
            "        \n",
            "        # Identify event periods\n",
            "        events = dr_ts[dr_ts > 0.01]\n",
            "        if len(events) > 0:\n",
            "            print(f'\\nDemand response events detected at {len(events)} timestamps')\n",
            "            print('Top 10 event periods:')\n",
            "            print(events.nlargest(10))\n"
        ]
    })

    # Cell 14l: Combined Flexibility Summary
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Combined Demand-Side Flexibility Summary\n",
            "\n",
            "Overview of all demand-side flexibility contributions."
        ]
    })

    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Combined demand-side flexibility summary\n",
            "print('DEMAND-SIDE FLEXIBILITY SUMMARY')\n",
            "print('=' * 60)\n",
            "\n",
            "summary_data = []\n",
            "\n",
            "# Heat pumps\n",
            "hp_links = network.links[network.links.carrier == 'heat pump']\n",
            "if len(hp_links) > 0:\n",
            "    hp_cols = [c for c in hp_links.index if c in network.links_t.p0.columns]\n",
            "    hp_energy = network.links_t.p0[hp_cols].sum().sum() if hp_cols else 0\n",
            "    summary_data.append({'Component': 'Heat Pumps', 'Capacity (MW)': hp_links.p_nom.sum(),\n",
            "                         'Energy (MWh)': hp_energy, 'Units': len(hp_links)})\n",
            "\n",
            "# EV charging\n",
            "ev_chargers = network.links[network.links.carrier == 'EV charger']\n",
            "if len(ev_chargers) > 0:\n",
            "    ev_cols = [c for c in ev_chargers.index if c in network.links_t.p0.columns]\n",
            "    ev_energy = network.links_t.p0[ev_cols].clip(lower=0).sum().sum() if ev_cols else 0\n",
            "    summary_data.append({'Component': 'EV Chargers', 'Capacity (MW)': ev_chargers.p_nom.sum(),\n",
            "                         'Energy (MWh)': ev_energy, 'Units': len(ev_chargers)})\n",
            "\n",
            "# V2G\n",
            "ev_v2g = network.links[network.links.carrier == 'V2G']\n",
            "if len(ev_v2g) > 0:\n",
            "    v2g_cols = [c for c in ev_v2g.index if c in network.links_t.p1.columns]\n",
            "    v2g_energy = network.links_t.p1[v2g_cols].clip(lower=0).sum().sum() if v2g_cols else 0\n",
            "    summary_data.append({'Component': 'V2G', 'Capacity (MW)': ev_v2g.p_nom.sum(),\n",
            "                         'Energy (MWh)': v2g_energy, 'Units': len(ev_v2g)})\n",
            "\n",
            "# Demand response\n",
            "dr_gens = network.generators[network.generators.carrier == 'demand response']\n",
            "if len(dr_gens) > 0:\n",
            "    dr_cols = [c for c in dr_gens.index if c in network.generators_t.p.columns]\n",
            "    dr_energy = network.generators_t.p[dr_cols].sum().sum() if dr_cols else 0\n",
            "    summary_data.append({'Component': 'Demand Response', 'Capacity (MW)': dr_gens.p_nom.sum(),\n",
            "                         'Energy (MWh)': dr_energy, 'Units': len(dr_gens)})\n",
            "\n",
            "if summary_data:\n",
            "    summary_df = pd.DataFrame(summary_data)\n",
            "    summary_df['Capacity (MW)'] = summary_df['Capacity (MW)'].apply(lambda x: f'{x:,.1f}')\n",
            "    summary_df['Energy (MWh)'] = summary_df['Energy (MWh)'].apply(lambda x: f'{x:,.0f}')\n",
            "    print(summary_df.to_string(index=False))\n",
            "    \n",
            "    # Pie chart of energy contribution\n",
            "    energy_data = pd.DataFrame(summary_data)\n",
            "    energy_data = energy_data[energy_data['Energy (MWh)'] > 0]\n",
            "    if len(energy_data) > 1:\n",
            "        fig = px.pie(energy_data, values='Energy (MWh)', names='Component',\n",
            "                     title='Demand-Side Flexibility Energy Contribution',\n",
            "                     color_discrete_sequence=px.colors.qualitative.Set2)\n",
            "        fig.update_traces(textposition='inside', textinfo='percent+label')\n",
            "        fig.update_layout(height=400)\n",
            "        fig.show()\n",
            "else:\n",
            "    print('No demand-side flexibility components found in network')\n"
        ]
    })

    # Cell 15: Advanced Analysis - Temporal patterns
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Advanced Analysis\n",
            "\n",
            "### Temporal Patterns and System Dynamics"
        ]
    })
    
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Interactive heatmap of hourly generation patterns\n",
            "# Aggregate generation by hour of day and day of year\n",
            "if len(network.snapshots) > 24:\n",
            "    total_gen = network.generators_t.p.sum(axis=1)\n",
            "    total_demand = network.loads_t.p_set.sum(axis=1)\n",
            "    \n",
            "    # Create DataFrame with datetime index\n",
            "    df_temporal = pd.DataFrame({\n",
            "        'generation': total_gen,\n",
            "        'demand': total_demand,\n",
            "        'hour': total_gen.index.hour,\n",
            "        'day': total_gen.index.dayofyear\n",
            "    })\n",
            "    \n",
            "    # Create hourly average pattern\n",
            "    hourly_pattern = df_temporal.groupby('hour')[['generation', 'demand']].mean()\n",
            "    \n",
            "    # Interactive line plot of hourly patterns\n",
            "    fig = go.Figure()\n",
            "    \n",
            "    fig.add_trace(go.Scatter(\n",
            "        x=hourly_pattern.index,\n",
            "        y=hourly_pattern['demand'] / 1000,\n",
            "        name='Average Demand',\n",
            "        line=dict(color='blue', width=2),\n",
            "        hovertemplate='Hour: %{x}<br>Demand: %{y:.1f} GW<extra></extra>'\n",
            "    ))\n",
            "    \n",
            "    fig.add_trace(go.Scatter(\n",
            "        x=hourly_pattern.index,\n",
            "        y=hourly_pattern['generation'] / 1000,\n",
            "        name='Average Generation',\n",
            "        line=dict(color='red', width=2),\n",
            "        hovertemplate='Hour: %{x}<br>Generation: %{y:.1f} GW<extra></extra>'\n",
            "    ))\n",
            "    \n",
            "    fig.update_layout(\n",
            "        title='Average Hourly Pattern',\n",
            "        xaxis_title='Hour of Day',\n",
            "        yaxis_title='Power (GW)',\n",
            "        template='plotly_white',\n",
            "        hovermode='x unified',\n",
            "        height=400\n",
            "    )\n",
            "    \n",
            "    fig.show()\n",
            "    \n",
            "    print(f'Peak demand hour: {hourly_pattern[\"demand\"].idxmax()}:00')\n",
            "    print(f'Minimum demand hour: {hourly_pattern[\"demand\"].idxmin()}:00')\n",
            "else:\n",
            "    print('Insufficient timesteps for temporal pattern analysis')"
        ]
    })
    
    # Cell 17: Congestion analysis over time
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "### Congestion Hotspots Over Time\n",
            "\n",
            "Identify when and where transmission congestion occurs."
        ]
    })
    
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Calculate transmission loading over time (handles both lines and links)\n",
            "has_lines = len(network.lines) > 0 and 's_nom' in network.lines.columns\n",
            "has_internal_links = len(network.links) > 0\n",
            "\n",
            "if has_lines:\n",
            "    # ETYS/Reduced network - use lines\n",
            "    loading_pct = (network.lines_t.p0.abs() / network.lines.s_nom * 100).fillna(0)\n",
            "    components = network.lines\n",
            "    element_type = 'Line'\n",
            "elif has_internal_links:\n",
            "    # Zonal network - use internal links only (exclude external and hydrogen links)\n",
            "    h2_carriers = ['electrolysis', 'H2_turbine', 'H2_power', 'H2', 'H2_gas']\n",
            "    is_external = (\n",
            "        network.links.bus0.str.lower().str.contains('external', na=False) |\n",
            "        network.links.bus1.str.lower().str.contains('external', na=False)\n",
            "    )\n",
            "    is_h2_link = network.links.carrier.isin(h2_carriers)\n",
            "    internal_links = network.links[~is_external & ~is_h2_link]\n",
            "    if len(internal_links) > 0:\n",
            "        link_flows = network.links_t.p0[internal_links.index].abs()\n",
            "        loading_pct = (link_flows / internal_links.p_nom * 100).fillna(0)\n",
            "        components = internal_links\n",
            "        element_type = 'Link'\n",
            "    else:\n",
            "        loading_pct = pd.DataFrame()\n",
            "        element_type = 'None'\n",
            "else:\n",
            "    loading_pct = pd.DataFrame()\n",
            "    element_type = 'None'\n",
            "\n",
            "if len(loading_pct.columns) > 0:\n",
            "    # Count congested elements at each timestep (>95% loading)\n",
            "    congested_count = (loading_pct >= 95).sum(axis=1)\n",
            "    \n",
            "    # Create time series plot\n",
            "    fig = go.Figure()\n",
            "    \n",
            "    fig.add_trace(go.Scatter(\n",
            "        x=congested_count.index,\n",
            "        y=congested_count.values,\n",
            "        name=f'Congested {element_type}s',\n",
            "        line=dict(color='#DC143C', width=1.5),\n",
            "        fill='tozeroy',\n",
            "        fillcolor='rgba(220, 20, 60, 0.2)',\n",
            "        hovertemplate='Time: %{x}<br>Congested: %{y}<extra></extra>'\n",
            "    ))\n",
            "    \n",
            "    fig.update_layout(\n",
            "        title=f'Transmission Congestion Over Time ({element_type}s >95% Loaded)',\n",
            "        xaxis_title='Time',\n",
            "        yaxis_title=f'Number of Congested {element_type}s',\n",
            "        template='plotly_white',\n",
            "        height=400\n",
            "    )\n",
            "    \n",
            "    fig.show()\n",
            "    \n",
            "    # Find most frequently congested elements\n",
            "    congestion_frequency = (loading_pct >= 95).sum(axis=0).sort_values(ascending=False)\n",
            "    top_congested = congestion_frequency.head(10)\n",
            "    \n",
            "    if len(top_congested) > 0 and top_congested.iloc[0] > 0:\n",
            "        print(f'\\nMost Frequently Congested {element_type}s:')\n",
            "        print(f'{element_type}'.ljust(50) + ' Congested Timesteps')\n",
            "        print('=' * 75)\n",
            "        for elem_id, count in top_congested.items():\n",
            "            if count > 0:\n",
            "                bus0 = components.loc[elem_id, 'bus0']\n",
            "                bus1 = components.loc[elem_id, 'bus1']\n",
            "                pct = count / len(network.snapshots) * 100\n",
            "                print(f'{bus0} - {bus1:<40} {count:>4} ({pct:.1f}%)')\n",
            "    else:\n",
            "        print(f'\\n✓ No significant transmission congestion detected')\n",
            "else:\n",
            "    print('No transmission elements found for congestion analysis')"
        ]
    })
    
    # Cell 14: Key performance indicators (keep existing)
    notebook["cells"].append({
        "cell_type": "markdown",
        "metadata": {},
        "source": [
            "## Key Performance Indicators"
        ]
    })
    
    notebook["cells"].append({
        "cell_type": "code",
        "execution_count": None,
        "metadata": {},
        "outputs": [],
        "source": [
            "# Calculate KPIs\n",
            "print(f'SCENARIO: {scenario_id}')\n",
            "print('=' * 80)\n",
            "print()\n",
            "\n",
            "total_demand = network.loads_t.p_set.sum().sum()\n",
            "total_generation = network.generators_t.p.sum().sum()\n",
            "\n",
            "# Load shedding\n",
            "ls_gens = network.generators[network.generators.carrier == 'load_shedding']\n",
            "load_shedding = network.generators_t.p[ls_gens.index].sum().sum() if len(ls_gens) > 0 else 0\n",
            "\n",
            "print(f'DEMAND:')\n",
            "print(f'  Total demand: {total_demand:,.0f} MWh')\n",
            "print(f'  Load shedding: {load_shedding:,.0f} MWh ({load_shedding/total_demand*100:.2f}%)')\n",
            "print(f'  Demand satisfied: {total_demand - load_shedding:,.0f} MWh ({(total_demand - load_shedding)/total_demand*100:.2f}%)')\n",
            "print()\n",
            "\n",
            "# Renewable share\n",
            "renewable_gens = network.generators[network.generators.carrier.isin(['wind_onshore', 'wind_offshore', 'solar_pv', 'large_hydro', 'small_hydro'])]\n",
            "renewable_gen = network.generators_t.p[renewable_gens.index].sum().sum()\n",
            "renewable_share = renewable_gen / (total_generation + load_shedding) * 100\n",
            "\n",
            "print(f'GENERATION:')\n",
            "print(f'  Total generation: {total_generation:,.0f} MWh')\n",
            "print(f'  Renewable generation: {renewable_gen:,.0f} MWh')\n",
            "print(f'  Renewable share: {renewable_share:.1f}%')\n",
            "print()\n",
            "\n",
            "# System cost\n",
            "if hasattr(network, 'objective'):\n",
            "    print(f'OPTIMIZATION:')\n",
            "    print(f'  Total system cost: £{network.objective:,.2f}')\n",
            "    if total_generation + load_shedding > 0:\n",
            "        cost_per_mwh = network.objective / (total_generation + load_shedding)\n",
            "        print(f'  Cost per MWh: £{cost_per_mwh:.2f}/MWh')\n",
            "    print()\n",
            "\n",
            "# Line statistics\n",
            "max_loading = abs(network.lines_t.p0 / network.lines.s_nom).max().max()\n",
            "mean_loading = abs(network.lines_t.p0 / network.lines.s_nom).mean().mean()\n",
            "n_congested = (abs(network.lines_t.p0 / network.lines.s_nom) >= 0.95).sum().sum()\n",
            "\n",
            "print(f'TRANSMISSION:')\n",
            "print(f'  Total lines: {len(network.lines)}')\n",
            "print(f'  Max line loading: {max_loading*100:.1f}%')\n",
            "print(f'  Mean line loading: {mean_loading*100:.1f}%')\n",
            "print(f'  Timesteps with congestion (≥95%): {n_congested}')\n",
            "print()\n",
            "\n",
            "# Hydrogen system\n",
            "has_electrolysis = len(network.links) > 0 and 'electrolysis' in network.links.carrier.values\n",
            "has_h2_turbines = len(network.links) > 0 and 'H2_turbine' in network.links.carrier.values\n",
            "\n",
            "if has_electrolysis or has_h2_turbines:\n",
            "    print(f'HYDROGEN SYSTEM:')\n",
            "    if has_electrolysis:\n",
            "        electrolysis = network.links[network.links.carrier == 'electrolysis']\n",
            "        elec_consumed = network.links_t.p0[electrolysis.index].sum().sum()\n",
            "        print(f'  Electrolysis capacity: {electrolysis.p_nom.sum():,.0f} MW')\n",
            "        print(f'  Electricity consumed: {elec_consumed:,.0f} MWh')\n",
            "    if has_h2_turbines:\n",
            "        h2_turbines = network.links[network.links.carrier == 'H2_turbine']\n",
            "        elec_generated = -network.links_t.p1[h2_turbines.index].sum().sum()\n",
            "        print(f'  H2 turbine capacity: {h2_turbines.p_nom.sum():,.0f} MW')\n",
            "        print(f'  Electricity generated: {elec_generated:,.0f} MWh')\n",
            "    if has_electrolysis and has_h2_turbines:\n",
            "        roundtrip = elec_generated / elec_consumed * 100 if elec_consumed > 0 else 0\n",
            "        print(f'  Round-trip efficiency: {roundtrip:.1f}%')\n",
            "    print()\n",
            "\n",
            "print('=' * 80)"
        ]
    })
    
    # Write notebook to file
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w') as f:
        json.dump(notebook, f, indent=2)
    
    logger.info(f"[OK] Notebook generated: {output_path}")
    
    # Return the notebook dictionary so it can be saved by callers
    return notebook


# ──────────────────────────────────────────────────────────────────────────────
# MAIN EXECUTION
# ──────────────────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    try:
        # Get parameters from Snakemake
        scenario_id = snakemake.params.scenario
        network_path = snakemake.input.network
        output_path = snakemake.output.notebook
        
        logger.info(f"=" * 80)
        logger.info(f"GENERATING ANALYSIS NOTEBOOK")
        logger.info(f"=" * 80)
        logger.info(f"Scenario: {scenario_id}")
        logger.info(f"Network: {network_path}")
        logger.info(f"Output: {output_path}")
        
        # Generate notebook
        create_analysis_notebook(scenario_id, network_path, output_path)
        
        logger.info(f"=" * 80)
        logger.info(f"NOTEBOOK GENERATION COMPLETE")
        logger.info(f"=" * 80)
        
    except Exception as e:
        logger.error(f"ERROR: Failed to generate notebook: {e}")
        raise

